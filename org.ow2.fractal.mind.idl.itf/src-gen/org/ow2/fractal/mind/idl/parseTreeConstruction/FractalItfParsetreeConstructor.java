/*
* generated by Xtext
*/
package org.ow2.fractal.mind.idl.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.ow2.fractal.mind.idl.services.FractalItfGrammarAccess;

import com.google.inject.Inject;

public class FractalItfParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private FractalItfGrammarAccess grammarAccess;
	
	@Override	
	public FractalItfGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ItfFile_Group(this, this, 0, inst);
			case 1: return new TypeDefinition_Group(this, this, 1, inst);
			case 2: return new TypedefSpecification_Group(this, this, 2, inst);
			case 3: return new QualifiedTypeSpecification_Group(this, this, 3, inst);
			case 4: return new TypeSpecification_Alternatives(this, this, 4, inst);
			case 5: return new StructOrUnionSpecification_Alternatives(this, this, 5, inst);
			case 6: return new StructOrUnionDefinition_Group(this, this, 6, inst);
			case 7: return new StructorUnionReference_Group(this, this, 7, inst);
			case 8: return new StructMember_Group(this, this, 8, inst);
			case 9: return new EnumSpecification_Alternatives(this, this, 9, inst);
			case 10: return new EnumDefinition_Group(this, this, 10, inst);
			case 11: return new EnumReference_Group(this, this, 11, inst);
			case 12: return new EnumMemberList_Group(this, this, 12, inst);
			case 13: return new EnumMember_Group(this, this, 13, inst);
			case 14: return new Declarators_Group(this, this, 14, inst);
			case 15: return new Declarator_Group(this, this, 15, inst);
			case 16: return new PointerSpecification_Group(this, this, 16, inst);
			case 17: return new Qualified_PointerSpecification_Group(this, this, 17, inst);
			case 18: return new DirectDeclarator_Group(this, this, 18, inst);
			case 19: return new ConstantDefinition_Group(this, this, 19, inst);
			case 20: return new InterfaceDefinition_Group(this, this, 20, inst);
			case 21: return new MethodDefinition_Group(this, this, 21, inst);
			case 22: return new ParameterList_Group(this, this, 22, inst);
			case 23: return new Parameter_Group(this, this, 23, inst);
			case 24: return new IncludeDirective_Group(this, this, 24, inst);
			case 25: return new Annotations_Group(this, this, 25, inst);
			case 26: return new Annotation_Group(this, this, 26, inst);
			case 27: return new AnnotationParameters_Group(this, this, 27, inst);
			case 28: return new AnnotationValuePairs_Group(this, this, 28, inst);
			case 29: return new AnnotationValuePair_Group(this, this, 29, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule ItfFile ****************
 *
 * ItfFile:
 *   includes+=IncludeDirective* (constant+=ConstantDefinition|type+=TypeDefinition)*
 *   interface=InterfaceDefinition ";"?;   // itf definition
 * 
 * 
 * 
 *     
 *         // Type definition part
 *
 **/

// includes+=IncludeDirective* (constant+=ConstantDefinition|type+=TypeDefinition)*
// interface=InterfaceDefinition ";"?
protected class ItfFile_Group extends GroupToken {
	
	public ItfFile_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getItfFileAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ItfFile_InterfaceAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getItfFileRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// includes+=IncludeDirective*
protected class ItfFile_IncludesAssignment_0 extends AssignmentToken  {
	
	public ItfFile_IncludesAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getIncludesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("includes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("includes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIncludeDirectiveRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getIncludesIncludeDirectiveParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// (constant+=ConstantDefinition|type+=TypeDefinition)*
protected class ItfFile_Alternatives_1 extends AlternativesToken {

	public ItfFile_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getItfFileAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ItfFile_ConstantAssignment_1_0(parent, this, 0, inst);
			case 1: return new ItfFile_TypeAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// constant+=ConstantDefinition
protected class ItfFile_ConstantAssignment_1_0 extends AssignmentToken  {
	
	public ItfFile_ConstantAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getConstantAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("constant",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("constant");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getConstantConstantDefinitionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// type+=TypeDefinition
protected class ItfFile_TypeAssignment_1_1 extends AssignmentToken  {
	
	public ItfFile_TypeAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getTypeTypeDefinitionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}


// interface=InterfaceDefinition
protected class ItfFile_InterfaceAssignment_2 extends AssignmentToken  {
	
	public ItfFile_InterfaceAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getInterfaceAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("interface",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("interface");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInterfaceDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getInterfaceInterfaceDefinitionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}


/************ end Rule ItfFile ****************/


/************ begin Rule TypeDefinition ****************
 *
 * TypeDefinition:
 *   (TypedefSpecification|StructOrUnionSpecification|EnumSpecification) ";";   // Type definition part
 *
 **/

// (TypedefSpecification|StructOrUnionSpecification|EnumSpecification) ";"
protected class TypeDefinition_Group extends GroupToken {
	
	public TypeDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_SemicolonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TypedefSpecification|StructOrUnionSpecification|EnumSpecification
protected class TypeDefinition_Alternatives_0 extends AlternativesToken {

	public TypeDefinition_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_TypedefSpecificationParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new TypeDefinition_StructOrUnionSpecificationParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new TypeDefinition_EnumSpecificationParserRuleCall_0_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// TypedefSpecification
protected class TypeDefinition_TypedefSpecificationParserRuleCall_0_0 extends RuleCallToken {
	
	public TypeDefinition_TypedefSpecificationParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getTypedefSpecificationParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypedefSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypedefSpecification_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypedefSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StructOrUnionSpecification
protected class TypeDefinition_StructOrUnionSpecificationParserRuleCall_0_1 extends RuleCallToken {
	
	public TypeDefinition_StructOrUnionSpecificationParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getStructOrUnionSpecificationParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructOrUnionSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumSpecification
protected class TypeDefinition_EnumSpecificationParserRuleCall_0_2 extends RuleCallToken {
	
	public TypeDefinition_EnumSpecificationParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getEnumSpecificationParserRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


// ";"
protected class TypeDefinition_SemicolonKeyword_1 extends KeywordToken  {
	
	public TypeDefinition_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getSemicolonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule TypeDefinition ****************/


/************ begin Rule TypedefSpecification ****************
 *
 * TypedefSpecification:
 *   "typedef" qualifedType=QualifiedTypeSpecification dec=Declarators;
 *
 **/

// "typedef" qualifedType=QualifiedTypeSpecification dec=Declarators
protected class TypedefSpecification_Group extends GroupToken {
	
	public TypedefSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypedefSpecification_DecAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypedefSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "typedef"
protected class TypedefSpecification_TypedefKeyword_0 extends KeywordToken  {
	
	public TypedefSpecification_TypedefKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getTypedefKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// qualifedType=QualifiedTypeSpecification
protected class TypedefSpecification_QualifedTypeAssignment_1 extends AssignmentToken  {
	
	public TypedefSpecification_QualifedTypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getQualifedTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifedType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifedType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypedefSpecificationAccess().getQualifedTypeQualifiedTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypedefSpecification_TypedefKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// dec=Declarators
protected class TypedefSpecification_DecAssignment_2 extends AssignmentToken  {
	
	public TypedefSpecification_DecAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getDecAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypedefSpecificationAccess().getDecDeclaratorsParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypedefSpecification_QualifedTypeAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule TypedefSpecification ****************/


/************ begin Rule QualifiedTypeSpecification ****************
 *
 * QualifiedTypeSpecification:
 *   typeQualifier+=TypeQualifier* typeSpec=TypeSpecification;
 *
 **/

// typeQualifier+=TypeQualifier* typeSpec=TypeSpecification
protected class QualifiedTypeSpecification_Group extends GroupToken {
	
	public QualifiedTypeSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQualifiedTypeSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_TypeSpecAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// typeQualifier+=TypeQualifier*
protected class QualifiedTypeSpecification_TypeQualifierAssignment_0 extends AssignmentToken  {
	
	public QualifiedTypeSpecification_TypeQualifierAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQualifiedTypeSpecificationAccess().getTypeQualifierAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_TypeQualifierAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeQualifier",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeQualifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getQualifiedTypeSpecificationAccess().getTypeQualifierTypeQualifierEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// typeSpec=TypeSpecification
protected class QualifiedTypeSpecification_TypeSpecAssignment_1 extends AssignmentToken  {
	
	public QualifiedTypeSpecification_TypeSpecAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQualifiedTypeSpecificationAccess().getTypeSpecAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeSpec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeSpec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getQualifiedTypeSpecificationAccess().getTypeSpecTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new QualifiedTypeSpecification_TypeQualifierAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}


/************ end Rule QualifiedTypeSpecification ****************/


/************ begin Rule TypeSpecification ****************
 *
 * TypeSpecification:
 *   typeDefName=TypedefName|StructOrUnionSpecification|EnumSpecification|
 *   typeSpecifier+=TypeSpecifier+;
 *
 **/

// typeDefName=TypedefName|StructOrUnionSpecification|EnumSpecification|
// typeSpecifier+=TypeSpecifier+
protected class TypeSpecification_Alternatives extends AlternativesToken {

	public TypeSpecification_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeSpecification_TypeDefNameAssignment_0(parent, this, 0, inst);
			case 1: return new TypeSpecification_StructOrUnionSpecificationParserRuleCall_1(parent, this, 1, inst);
			case 2: return new TypeSpecification_EnumSpecificationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new TypeSpecification_TypeSpecifierAssignment_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// typeDefName=TypedefName
protected class TypeSpecification_TypeDefNameAssignment_0 extends AssignmentToken  {
	
	public TypeSpecification_TypeDefNameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getTypeDefNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeDefName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeDefName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getTypeSpecificationAccess().getTypeDefNameTypedefNameParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// StructOrUnionSpecification
protected class TypeSpecification_StructOrUnionSpecificationParserRuleCall_1 extends RuleCallToken {
	
	public TypeSpecification_StructOrUnionSpecificationParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getStructOrUnionSpecificationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructOrUnionSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumSpecification
protected class TypeSpecification_EnumSpecificationParserRuleCall_2 extends RuleCallToken {
	
	public TypeSpecification_EnumSpecificationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getEnumSpecificationParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// typeSpecifier+=TypeSpecifier+
protected class TypeSpecification_TypeSpecifierAssignment_3 extends AssignmentToken  {
	
	public TypeSpecification_TypeSpecifierAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getTypeSpecifierAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeSpecification_TypeSpecifierAssignment_3(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeSpecifier",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeSpecifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getTypeSpecificationAccess().getTypeSpecifierTypeSpecifierEnumRuleCall_3_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule TypeSpecification ****************/



/************ begin Rule StructOrUnionSpecification ****************
 *
 * StructOrUnionSpecification:
 *   StructOrUnionDefinition|StructorUnionReference;
 *
 **/

// StructOrUnionDefinition|StructorUnionReference
protected class StructOrUnionSpecification_Alternatives extends AlternativesToken {

	public StructOrUnionSpecification_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getStructOrUnionSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionSpecification_StructOrUnionDefinitionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new StructOrUnionSpecification_StructorUnionReferenceParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// StructOrUnionDefinition
protected class StructOrUnionSpecification_StructOrUnionDefinitionParserRuleCall_0 extends RuleCallToken {
	
	public StructOrUnionSpecification_StructOrUnionDefinitionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructOrUnionSpecificationAccess().getStructOrUnionDefinitionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructOrUnionDefinition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionDefinitionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StructorUnionReference
protected class StructOrUnionSpecification_StructorUnionReferenceParserRuleCall_1 extends RuleCallToken {
	
	public StructOrUnionSpecification_StructorUnionReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructOrUnionSpecificationAccess().getStructorUnionReferenceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructorUnionReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructorUnionReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructorUnionReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule StructOrUnionSpecification ****************/


/************ begin Rule StructOrUnionDefinition ****************
 *
 * StructOrUnionDefinition:
 *   struct=StructOrUnion id=ID? "{" structMember+=StructMember* "}";
 *
 **/

// struct=StructOrUnion id=ID? "{" structMember+=StructMember* "}"
protected class StructOrUnionDefinition_Group extends GroupToken {
	
	public StructOrUnionDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// struct=StructOrUnion
protected class StructOrUnionDefinition_StructAssignment_0 extends AssignmentToken  {
	
	public StructOrUnionDefinition_StructAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getStructAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("struct",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("struct");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getStructOrUnionDefinitionAccess().getStructStructOrUnionParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// id=ID?
protected class StructOrUnionDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public StructOrUnionDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_StructAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStructOrUnionDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class StructOrUnionDefinition_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public StructOrUnionDefinition_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_IdAssignment_1(parent, this, 0, inst);
			case 1: return new StructOrUnionDefinition_StructAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// structMember+=StructMember*
protected class StructOrUnionDefinition_StructMemberAssignment_3 extends AssignmentToken  {
	
	public StructOrUnionDefinition_StructMemberAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getStructMemberAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("structMember",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("structMember");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStructMemberRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructOrUnionDefinitionAccess().getStructMemberStructMemberParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StructOrUnionDefinition_StructMemberAssignment_3(parent, next, actIndex, consumed);
			case 1: return new StructOrUnionDefinition_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class StructOrUnionDefinition_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public StructOrUnionDefinition_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_StructMemberAssignment_3(parent, this, 0, inst);
			case 1: return new StructOrUnionDefinition_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule StructOrUnionDefinition ****************/


/************ begin Rule StructorUnionReference ****************
 *
 * StructorUnionReference:
 *   struct=StructOrUnion id=ID;
 *
 **/

// struct=StructOrUnion id=ID
protected class StructorUnionReference_Group extends GroupToken {
	
	public StructorUnionReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructorUnionReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructorUnionReference_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructorUnionReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// struct=StructOrUnion
protected class StructorUnionReference_StructAssignment_0 extends AssignmentToken  {
	
	public StructorUnionReference_StructAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructorUnionReferenceAccess().getStructAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("struct",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("struct");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getStructorUnionReferenceAccess().getStructStructOrUnionParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// id=ID
protected class StructorUnionReference_IdAssignment_1 extends AssignmentToken  {
	
	public StructorUnionReference_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructorUnionReferenceAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructorUnionReference_StructAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStructorUnionReferenceAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule StructorUnionReference ****************/



/************ begin Rule StructMember ****************
 *
 * StructMember:
 *   annotations=Annotations qualType=QualifiedTypeSpecification dec=Declarators (":" INT
 *   )? ";";
 *
 **/

// annotations=Annotations qualType=QualifiedTypeSpecification dec=Declarators (":" INT
// )? ";"
protected class StructMember_Group extends GroupToken {
	
	public StructMember_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_SemicolonKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructMemberRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class StructMember_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public StructMember_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructMemberAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// qualType=QualifiedTypeSpecification
protected class StructMember_QualTypeAssignment_1 extends AssignmentToken  {
	
	public StructMember_QualTypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getQualTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructMemberAccess().getQualTypeQualifiedTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StructMember_AnnotationsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// dec=Declarators
protected class StructMember_DecAssignment_2 extends AssignmentToken  {
	
	public StructMember_DecAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getDecAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructMemberAccess().getDecDeclaratorsParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StructMember_QualTypeAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// (":" INT)?
protected class StructMember_Group_3 extends GroupToken {
	
	public StructMember_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_INTTerminalRuleCall_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class StructMember_ColonKeyword_3_0 extends KeywordToken  {
	
	public StructMember_ColonKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getColonKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_DecAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// INT
protected class StructMember_INTTerminalRuleCall_3_1 extends UnassignedTextToken {

	public StructMember_INTTerminalRuleCall_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getINTTerminalRuleCall_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_ColonKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// ";"
protected class StructMember_SemicolonKeyword_4 extends KeywordToken  {
	
	public StructMember_SemicolonKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getSemicolonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_Group_3(parent, this, 0, inst);
			case 1: return new StructMember_DecAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule StructMember ****************/


/************ begin Rule EnumSpecification ****************
 *
 * EnumSpecification:
 *   EnumDefinition|EnumReference;
 *
 **/

// EnumDefinition|EnumReference
protected class EnumSpecification_Alternatives extends AlternativesToken {

	public EnumSpecification_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEnumSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumSpecification_EnumDefinitionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new EnumSpecification_EnumReferenceParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// EnumDefinition
protected class EnumSpecification_EnumDefinitionParserRuleCall_0 extends RuleCallToken {
	
	public EnumSpecification_EnumDefinitionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumSpecificationAccess().getEnumDefinitionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumDefinition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumDefinitionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumReference
protected class EnumSpecification_EnumReferenceParserRuleCall_1 extends RuleCallToken {
	
	public EnumSpecification_EnumReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumSpecificationAccess().getEnumReferenceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule EnumSpecification ****************/


/************ begin Rule EnumDefinition ****************
 *
 * EnumDefinition:
 *   "enum" id=ID? "{" enumMemberList=EnumMemberList "}";
 *
 **/

// "enum" id=ID? "{" enumMemberList=EnumMemberList "}"
protected class EnumDefinition_Group extends GroupToken {
	
	public EnumDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "enum"
protected class EnumDefinition_EnumKeyword_0 extends KeywordToken  {
	
	public EnumDefinition_EnumKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getEnumKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID?
protected class EnumDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public EnumDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_EnumKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class EnumDefinition_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public EnumDefinition_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_IdAssignment_1(parent, this, 0, inst);
			case 1: return new EnumDefinition_EnumKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// enumMemberList=EnumMemberList
protected class EnumDefinition_EnumMemberListAssignment_3 extends AssignmentToken  {
	
	public EnumDefinition_EnumMemberListAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getEnumMemberListAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("enumMemberList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("enumMemberList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumMemberListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumDefinitionAccess().getEnumMemberListEnumMemberListParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumDefinition_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class EnumDefinition_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public EnumDefinition_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_EnumMemberListAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule EnumDefinition ****************/


/************ begin Rule EnumReference ****************
 *
 * EnumReference:
 *   "enum" id=ID;
 *
 **/

// "enum" id=ID
protected class EnumReference_Group extends GroupToken {
	
	public EnumReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumReference_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "enum"
protected class EnumReference_EnumKeyword_0 extends KeywordToken  {
	
	public EnumReference_EnumKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumReferenceAccess().getEnumKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID
protected class EnumReference_IdAssignment_1 extends AssignmentToken  {
	
	public EnumReference_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumReferenceAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumReference_EnumKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumReferenceAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule EnumReference ****************/


/************ begin Rule EnumMemberList ****************
 *
 * EnumMemberList:
 *   EnumMember ("," enumMember+=EnumMember)*;
 *
 **/

// EnumMember ("," enumMember+=EnumMember)*
protected class EnumMemberList_Group extends GroupToken {
	
	public EnumMemberList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_Group_1(parent, this, 0, inst);
			case 1: return new EnumMemberList_EnumMemberParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumMemberListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// EnumMember
protected class EnumMemberList_EnumMemberParserRuleCall_0 extends RuleCallToken {
	
	public EnumMemberList_EnumMemberParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getEnumMemberParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumMember_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumMemberRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ("," enumMember+=EnumMember)*
protected class EnumMemberList_Group_1 extends GroupToken {
	
	public EnumMemberList_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_EnumMemberAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class EnumMemberList_CommaKeyword_1_0 extends KeywordToken  {
	
	public EnumMemberList_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_Group_1(parent, this, 0, inst);
			case 1: return new EnumMemberList_EnumMemberParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// enumMember+=EnumMember
protected class EnumMemberList_EnumMemberAssignment_1_1 extends AssignmentToken  {
	
	public EnumMemberList_EnumMemberAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getEnumMemberAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("enumMember",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("enumMember");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumMemberRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumMemberListAccess().getEnumMemberEnumMemberParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumMemberList_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule EnumMemberList ****************/


/************ begin Rule EnumMember ****************
 *
 * EnumMember:
 *   annotations=Annotations id=ID ("=" INT)?;
 *
 **/

// annotations=Annotations id=ID ("=" INT)?
protected class EnumMember_Group extends GroupToken {
	
	public EnumMember_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_Group_2(parent, this, 0, inst);
			case 1: return new EnumMember_IdAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumMemberRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class EnumMember_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public EnumMember_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumMemberAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// id=ID
protected class EnumMember_IdAssignment_1 extends AssignmentToken  {
	
	public EnumMember_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_AnnotationsAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumMemberAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("=" INT)?
protected class EnumMember_Group_2 extends GroupToken {
	
	public EnumMember_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_INTTerminalRuleCall_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class EnumMember_EqualsSignKeyword_2_0 extends KeywordToken  {
	
	public EnumMember_EqualsSignKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getEqualsSignKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// INT
protected class EnumMember_INTTerminalRuleCall_2_1 extends UnassignedTextToken {

	public EnumMember_INTTerminalRuleCall_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getINTTerminalRuleCall_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_EqualsSignKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule EnumMember ****************/


/************ begin Rule Declarators ****************
 *
 * Declarators:
 *   dec=Declarator ("," declaratorList+=Declarator)*;
 *
 **/

// dec=Declarator ("," declaratorList+=Declarator)*
protected class Declarators_Group extends GroupToken {
	
	public Declarators_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group_1(parent, this, 0, inst);
			case 1: return new Declarators_DecAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclaratorsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// dec=Declarator
protected class Declarators_DecAssignment_0 extends AssignmentToken  {
	
	public Declarators_DecAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getDecAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorsAccess().getDecDeclaratorParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," declaratorList+=Declarator)*
protected class Declarators_Group_1 extends GroupToken {
	
	public Declarators_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_DeclaratorListAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Declarators_CommaKeyword_1_0 extends KeywordToken  {
	
	public Declarators_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group_1(parent, this, 0, inst);
			case 1: return new Declarators_DecAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// declaratorList+=Declarator
protected class Declarators_DeclaratorListAssignment_1_1 extends AssignmentToken  {
	
	public Declarators_DeclaratorListAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getDeclaratorListAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("declaratorList",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("declaratorList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorsAccess().getDeclaratorListDeclaratorParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Declarators_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Declarators ****************/


/************ begin Rule Declarator ****************
 *
 * Declarator:
 *   pointer=PointerSpecification dc=DirectDeclarator; 
 * 
 * 
 *       / *
 * AbstractDeclarator:
 *   pointer=PointerSpecification dc=AbstractDirectDeclarator;
 *   * /
 *
 **/

// pointer=PointerSpecification dc=DirectDeclarator
protected class Declarator_Group extends GroupToken {
	
	public Declarator_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_DcAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// pointer=PointerSpecification
protected class Declarator_PointerAssignment_0 extends AssignmentToken  {
	
	public Declarator_PointerAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getPointerAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PointerSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("pointer",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("pointer");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPointerSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorAccess().getPointerPointerSpecificationParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// dc=DirectDeclarator
protected class Declarator_DcAssignment_1 extends AssignmentToken  {
	
	public Declarator_DcAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getDcAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dc",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dc");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDirectDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorAccess().getDcDirectDeclaratorParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Declarator_PointerAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Declarator ****************/


/************ begin Rule PointerSpecification ****************
 *
 * PointerSpecification:
 *   {PointerSpecification} qualifiedPointer+=Qualified_PointerSpecification*;   / *
 * AbstractDeclarator:
 *   pointer=PointerSpecification dc=AbstractDirectDeclarator;
 *   * /
 *
 **/

// {PointerSpecification} qualifiedPointer+=Qualified_PointerSpecification*
protected class PointerSpecification_Group extends GroupToken {
	
	public PointerSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPointerSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PointerSpecification_QualifiedPointerAssignment_1(parent, this, 0, inst);
			case 1: return new PointerSpecification_PointerSpecificationAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPointerSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {PointerSpecification}
protected class PointerSpecification_PointerSpecificationAction_0 extends ActionToken  {

	public PointerSpecification_PointerSpecificationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPointerSpecificationAccess().getPointerSpecificationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPointerSpecificationAccess().getPointerSpecificationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// qualifiedPointer+=Qualified_PointerSpecification*
protected class PointerSpecification_QualifiedPointerAssignment_1 extends AssignmentToken  {
	
	public PointerSpecification_QualifiedPointerAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPointerSpecificationAccess().getQualifiedPointerAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Qualified_PointerSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifiedPointer",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifiedPointer");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualified_PointerSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPointerSpecificationAccess().getQualifiedPointerQualified_PointerSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PointerSpecification_QualifiedPointerAssignment_1(parent, next, actIndex, consumed);
			case 1: return new PointerSpecification_PointerSpecificationAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule PointerSpecification ****************/


/************ begin Rule Qualified_PointerSpecification ****************
 *
 * Qualified_PointerSpecification:
 *   {Qualified_PointerSpecification} "*" typeQualifier+=TypeQualifier*;
 *
 **/

// {Qualified_PointerSpecification} "*" typeQualifier+=TypeQualifier*
protected class Qualified_PointerSpecification_Group extends GroupToken {
	
	public Qualified_PointerSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQualified_PointerSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Qualified_PointerSpecification_TypeQualifierAssignment_2(parent, this, 0, inst);
			case 1: return new Qualified_PointerSpecification_AsteriskKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getQualified_PointerSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Qualified_PointerSpecification}
protected class Qualified_PointerSpecification_Qualified_PointerSpecificationAction_0 extends ActionToken  {

	public Qualified_PointerSpecification_Qualified_PointerSpecificationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getQualified_PointerSpecificationAccess().getQualified_PointerSpecificationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getQualified_PointerSpecificationAccess().getQualified_PointerSpecificationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "*"
protected class Qualified_PointerSpecification_AsteriskKeyword_1 extends KeywordToken  {
	
	public Qualified_PointerSpecification_AsteriskKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getQualified_PointerSpecificationAccess().getAsteriskKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Qualified_PointerSpecification_Qualified_PointerSpecificationAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeQualifier+=TypeQualifier*
protected class Qualified_PointerSpecification_TypeQualifierAssignment_2 extends AssignmentToken  {
	
	public Qualified_PointerSpecification_TypeQualifierAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQualified_PointerSpecificationAccess().getTypeQualifierAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Qualified_PointerSpecification_TypeQualifierAssignment_2(parent, this, 0, inst);
			case 1: return new Qualified_PointerSpecification_AsteriskKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeQualifier",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeQualifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getQualified_PointerSpecificationAccess().getTypeQualifierTypeQualifierEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Qualified_PointerSpecification ****************/


/************ begin Rule DirectDeclarator ****************
 *
 * DirectDeclarator:
 *   (id=ID|"(" dec=Declarator ")") array+=ArraySpecification*; 
 * 
 * 
 *           / *AbstractDirectDeclarator:
 *   '(' dec=AbstractDeclarator ')' array+=ArraySpecification*;* /
 *
 **/

// (id=ID|"(" dec=Declarator ")") array+=ArraySpecification*
protected class DirectDeclarator_Group extends GroupToken {
	
	public DirectDeclarator_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_ArrayAssignment_1(parent, this, 0, inst);
			case 1: return new DirectDeclarator_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDirectDeclaratorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// id=ID|"(" dec=Declarator ")"
protected class DirectDeclarator_Alternatives_0 extends AlternativesToken {

	public DirectDeclarator_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_IdAssignment_0_0(parent, this, 0, inst);
			case 1: return new DirectDeclarator_Group_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// id=ID
protected class DirectDeclarator_IdAssignment_0_0 extends AssignmentToken  {
	
	public DirectDeclarator_IdAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getIdAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDirectDeclaratorAccess().getIdIDTerminalRuleCall_0_0_0();
			return obj;
		}
		return null;
	}

}

// "(" dec=Declarator ")"
protected class DirectDeclarator_Group_0_1 extends GroupToken {
	
	public DirectDeclarator_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_RightParenthesisKeyword_0_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class DirectDeclarator_LeftParenthesisKeyword_0_1_0 extends KeywordToken  {
	
	public DirectDeclarator_LeftParenthesisKeyword_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getLeftParenthesisKeyword_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// dec=Declarator
protected class DirectDeclarator_DecAssignment_0_1_1 extends AssignmentToken  {
	
	public DirectDeclarator_DecAssignment_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getDecAssignment_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDirectDeclaratorAccess().getDecDeclaratorParserRuleCall_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DirectDeclarator_LeftParenthesisKeyword_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class DirectDeclarator_RightParenthesisKeyword_0_1_2 extends KeywordToken  {
	
	public DirectDeclarator_RightParenthesisKeyword_0_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getRightParenthesisKeyword_0_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_DecAssignment_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// array+=ArraySpecification*
protected class DirectDeclarator_ArrayAssignment_1 extends AssignmentToken  {
	
	public DirectDeclarator_ArrayAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getArrayAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_ArrayAssignment_1(parent, this, 0, inst);
			case 1: return new DirectDeclarator_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("array",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("array");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getDirectDeclaratorAccess().getArrayArraySpecificationParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule DirectDeclarator ****************/




/************ begin Rule ConstantDefinition ****************
 *
 * ConstantDefinition:
 *   "#define" id=ID;   // Interface definition part
 *
 **/

// "#define" id=ID
protected class ConstantDefinition_Group extends GroupToken {
	
	public ConstantDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "#define"
protected class ConstantDefinition_DefineKeyword_0 extends KeywordToken  {
	
	public ConstantDefinition_DefineKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getDefineKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID
protected class ConstantDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public ConstantDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_DefineKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getConstantDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule ConstantDefinition ****************/


/************ begin Rule InterfaceDefinition ****************
 *
 * InterfaceDefinition:
 *   annotations=Annotations "interface" "unmanaged"? fqn=FullyQualifiedName (":" fqn2=
 *   FullyQualifiedName)? "{" methodDef+=MethodDefinition* "}";
 *
 **/

// annotations=Annotations "interface" "unmanaged"? fqn=FullyQualifiedName (":" fqn2=
// FullyQualifiedName)? "{" methodDef+=MethodDefinition* "}"
protected class InterfaceDefinition_Group extends GroupToken {
	
	public InterfaceDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_RightCurlyBracketKeyword_7(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInterfaceDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class InterfaceDefinition_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public InterfaceDefinition_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInterfaceDefinitionAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// "interface"
protected class InterfaceDefinition_InterfaceKeyword_1 extends KeywordToken  {
	
	public InterfaceDefinition_InterfaceKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getInterfaceKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_AnnotationsAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// fqn=FullyQualifiedName
protected class InterfaceDefinition_FqnAssignment_3 extends AssignmentToken  {
	
	public InterfaceDefinition_FqnAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getFqnAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_InterfaceKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fqn",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fqn");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getInterfaceDefinitionAccess().getFqnFullyQualifiedNameParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// (":" fqn2=FullyQualifiedName)?
protected class InterfaceDefinition_Group_4 extends GroupToken {
	
	public InterfaceDefinition_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_Fqn2Assignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class InterfaceDefinition_ColonKeyword_4_0 extends KeywordToken  {
	
	public InterfaceDefinition_ColonKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getColonKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_FqnAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// fqn2=FullyQualifiedName
protected class InterfaceDefinition_Fqn2Assignment_4_1 extends AssignmentToken  {
	
	public InterfaceDefinition_Fqn2Assignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getFqn2Assignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_ColonKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fqn2",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fqn2");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getInterfaceDefinitionAccess().getFqn2FullyQualifiedNameParserRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}


// "{"
protected class InterfaceDefinition_LeftCurlyBracketKeyword_5 extends KeywordToken  {
	
	public InterfaceDefinition_LeftCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getLeftCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_Group_4(parent, this, 0, inst);
			case 1: return new InterfaceDefinition_FqnAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// methodDef+=MethodDefinition*
protected class InterfaceDefinition_MethodDefAssignment_6 extends AssignmentToken  {
	
	public InterfaceDefinition_MethodDefAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getMethodDefAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("methodDef",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("methodDef");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMethodDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInterfaceDefinitionAccess().getMethodDefMethodDefinitionParserRuleCall_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InterfaceDefinition_MethodDefAssignment_6(parent, next, actIndex, consumed);
			case 1: return new InterfaceDefinition_LeftCurlyBracketKeyword_5(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class InterfaceDefinition_RightCurlyBracketKeyword_7 extends KeywordToken  {
	
	public InterfaceDefinition_RightCurlyBracketKeyword_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getRightCurlyBracketKeyword_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_MethodDefAssignment_6(parent, this, 0, inst);
			case 1: return new InterfaceDefinition_LeftCurlyBracketKeyword_5(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule InterfaceDefinition ****************/


/************ begin Rule MethodDefinition ****************
 *
 * MethodDefinition:
 *   annotations=Annotations qualifiedTypeSpec=QualifiedTypeSpecification id=ID ("("
 *   "void"? ")"|"(" ParameterList=ParameterList ")") ";";
 *
 **/

// annotations=Annotations qualifiedTypeSpec=QualifiedTypeSpecification id=ID ("("
// "void"? ")"|"(" ParameterList=ParameterList ")") ";"
protected class MethodDefinition_Group extends GroupToken {
	
	public MethodDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_SemicolonKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMethodDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class MethodDefinition_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public MethodDefinition_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethodDefinitionAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// qualifiedTypeSpec=QualifiedTypeSpecification
protected class MethodDefinition_QualifiedTypeSpecAssignment_1 extends AssignmentToken  {
	
	public MethodDefinition_QualifiedTypeSpecAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getQualifiedTypeSpecAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifiedTypeSpec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifiedTypeSpec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethodDefinitionAccess().getQualifiedTypeSpecQualifiedTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MethodDefinition_AnnotationsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// id=ID
protected class MethodDefinition_IdAssignment_2 extends AssignmentToken  {
	
	public MethodDefinition_IdAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getIdAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_QualifiedTypeSpecAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMethodDefinitionAccess().getIdIDTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "(" "void"? ")"|"(" ParameterList=ParameterList ")"
protected class MethodDefinition_Alternatives_3 extends AlternativesToken {

	public MethodDefinition_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getAlternatives_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_Group_3_0(parent, this, 0, inst);
			case 1: return new MethodDefinition_Group_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "(" "void"? ")"
protected class MethodDefinition_Group_3_0 extends GroupToken {
	
	public MethodDefinition_Group_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getGroup_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_RightParenthesisKeyword_3_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class MethodDefinition_LeftParenthesisKeyword_3_0_0 extends KeywordToken  {
	
	public MethodDefinition_LeftParenthesisKeyword_3_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getLeftParenthesisKeyword_3_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_IdAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ")"
protected class MethodDefinition_RightParenthesisKeyword_3_0_2 extends KeywordToken  {
	
	public MethodDefinition_RightParenthesisKeyword_3_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getRightParenthesisKeyword_3_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_LeftParenthesisKeyword_3_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "(" ParameterList=ParameterList ")"
protected class MethodDefinition_Group_3_1 extends GroupToken {
	
	public MethodDefinition_Group_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getGroup_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_RightParenthesisKeyword_3_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class MethodDefinition_LeftParenthesisKeyword_3_1_0 extends KeywordToken  {
	
	public MethodDefinition_LeftParenthesisKeyword_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getLeftParenthesisKeyword_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_IdAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ParameterList=ParameterList
protected class MethodDefinition_ParameterListAssignment_3_1_1 extends AssignmentToken  {
	
	public MethodDefinition_ParameterListAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getParameterListAssignment_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ParameterList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ParameterList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethodDefinitionAccess().getParameterListParameterListParserRuleCall_3_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MethodDefinition_LeftParenthesisKeyword_3_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class MethodDefinition_RightParenthesisKeyword_3_1_2 extends KeywordToken  {
	
	public MethodDefinition_RightParenthesisKeyword_3_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getRightParenthesisKeyword_3_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_ParameterListAssignment_3_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// ";"
protected class MethodDefinition_SemicolonKeyword_4 extends KeywordToken  {
	
	public MethodDefinition_SemicolonKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getSemicolonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_Alternatives_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule MethodDefinition ****************/


/************ begin Rule ParameterList ****************
 *
 * ParameterList:
 *   param=Parameter ("," params+=Parameter)* ("," "...")?;
 *
 **/

// param=Parameter ("," params+=Parameter)* ("," "...")?
protected class ParameterList_Group extends GroupToken {
	
	public ParameterList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group_1(parent, this, 0, inst);
			case 1: return new ParameterList_ParamAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// param=Parameter
protected class ParameterList_ParamAssignment_0 extends AssignmentToken  {
	
	public ParameterList_ParamAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterListAccess().getParamAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("param",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("param");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterListAccess().getParamParameterParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," params+=Parameter)*
protected class ParameterList_Group_1 extends GroupToken {
	
	public ParameterList_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterListAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_ParamsAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ParameterList_CommaKeyword_1_0 extends KeywordToken  {
	
	public ParameterList_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParameterListAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group_1(parent, this, 0, inst);
			case 1: return new ParameterList_ParamAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Parameter
protected class ParameterList_ParamsAssignment_1_1 extends AssignmentToken  {
	
	public ParameterList_ParamsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterListAccess().getParamsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterListAccess().getParamsParameterParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ParameterList_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ParameterList ****************/


/************ begin Rule Parameter ****************
 *
 * Parameter:
 *   annotations=Annotations ParameterQualifier+=ParameterQualifier* qualifiedTypeSpec=
 *   QualifiedTypeSpecification dec=Declarator?;
 *
 **/

// annotations=Annotations ParameterQualifier+=ParameterQualifier* qualifiedTypeSpec=
// QualifiedTypeSpecification dec=Declarator?
protected class Parameter_Group extends GroupToken {
	
	public Parameter_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_DecAssignment_3(parent, this, 0, inst);
			case 1: return new Parameter_QualifiedTypeSpecAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class Parameter_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public Parameter_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ParameterQualifier+=ParameterQualifier*
protected class Parameter_ParameterQualifierAssignment_1 extends AssignmentToken  {
	
	public Parameter_ParameterQualifierAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getParameterQualifierAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_ParameterQualifierAssignment_1(parent, this, 0, inst);
			case 1: return new Parameter_AnnotationsAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ParameterQualifier",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ParameterQualifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getParameterAccess().getParameterQualifierParameterQualifierEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// qualifiedTypeSpec=QualifiedTypeSpecification
protected class Parameter_QualifiedTypeSpecAssignment_2 extends AssignmentToken  {
	
	public Parameter_QualifiedTypeSpecAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getQualifiedTypeSpecAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifiedTypeSpec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifiedTypeSpec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterAccess().getQualifiedTypeSpecQualifiedTypeSpecificationParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Parameter_ParameterQualifierAssignment_1(parent, next, actIndex, consumed);
			case 1: return new Parameter_AnnotationsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// dec=Declarator?
protected class Parameter_DecAssignment_3 extends AssignmentToken  {
	
	public Parameter_DecAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getDecAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterAccess().getDecDeclaratorParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Parameter_QualifiedTypeSpecAssignment_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Parameter ****************/


/************ begin Rule IncludeDirective ****************
 *
 * IncludeDirective:
 *   "#include" (importedURI=STRING|includeID=IncludeLib);   // include directive
 *
 **/

// "#include" (importedURI=STRING|includeID=IncludeLib)
protected class IncludeDirective_Group extends GroupToken {
	
	public IncludeDirective_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIncludeDirectiveRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "#include"
protected class IncludeDirective_IncludeKeyword_0 extends KeywordToken  {
	
	public IncludeDirective_IncludeKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getIncludeKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// importedURI=STRING|includeID=IncludeLib
protected class IncludeDirective_Alternatives_1 extends AlternativesToken {

	public IncludeDirective_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_ImportedURIAssignment_1_0(parent, this, 0, inst);
			case 1: return new IncludeDirective_IncludeIDAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// importedURI=STRING
protected class IncludeDirective_ImportedURIAssignment_1_0 extends AssignmentToken  {
	
	public IncludeDirective_ImportedURIAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getImportedURIAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_IncludeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("importedURI",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("importedURI");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getIncludeDirectiveAccess().getImportedURISTRINGTerminalRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// includeID=IncludeLib
protected class IncludeDirective_IncludeIDAssignment_1_1 extends AssignmentToken  {
	
	public IncludeDirective_IncludeIDAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getIncludeIDAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_IncludeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("includeID",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("includeID");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getIncludeDirectiveAccess().getIncludeIDIncludeLibTerminalRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule IncludeDirective ****************/


/************ begin Rule Annotations ****************
 *
 * Annotations:
 *   {Annotations} annotations+=Annotation*;
 *
 **/

// {Annotations} annotations+=Annotation*
protected class Annotations_Group extends GroupToken {
	
	public Annotations_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_AnnotationsAssignment_1(parent, this, 0, inst);
			case 1: return new Annotations_AnnotationsAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Annotations}
protected class Annotations_AnnotationsAction_0 extends ActionToken  {

	public Annotations_AnnotationsAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAnnotationsAccess().getAnnotationsAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationsAccess().getAnnotationsAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// annotations+=Annotation*
protected class Annotations_AnnotationsAssignment_1 extends AssignmentToken  {
	
	public Annotations_AnnotationsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationsAccess().getAnnotationsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationsAccess().getAnnotationsAnnotationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Annotations_AnnotationsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new Annotations_AnnotationsAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Annotations ****************/


/************ begin Rule Annotation ****************
 *
 * Annotation:
 *   "@" fqn=FullyQualifiedName annotationParamaters=AnnotationParameters?;
 *
 **/

// "@" fqn=FullyQualifiedName annotationParamaters=AnnotationParameters?
protected class Annotation_Group extends GroupToken {
	
	public Annotation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotation_AnnotationParamatersAssignment_2(parent, this, 0, inst);
			case 1: return new Annotation_FqnAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "@"
protected class Annotation_CommercialAtKeyword_0 extends KeywordToken  {
	
	public Annotation_CommercialAtKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationAccess().getCommercialAtKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// fqn=FullyQualifiedName
protected class Annotation_FqnAssignment_1 extends AssignmentToken  {
	
	public Annotation_FqnAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationAccess().getFqnAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotation_CommercialAtKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fqn",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fqn");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getAnnotationAccess().getFqnFullyQualifiedNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// annotationParamaters=AnnotationParameters?
protected class Annotation_AnnotationParamatersAssignment_2 extends AssignmentToken  {
	
	public Annotation_AnnotationParamatersAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationAccess().getAnnotationParamatersAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotationParamaters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotationParamaters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationParametersRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationAccess().getAnnotationParamatersAnnotationParametersParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Annotation_FqnAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Annotation ****************/


/************ begin Rule AnnotationParameters ****************
 *
 * AnnotationParameters:
 *   {AnnotationParameters} "(" (valuePair=AnnotationValuePairs|value=AnnotationValue)?
 *   ")";
 *
 **/

// {AnnotationParameters} "(" (valuePair=AnnotationValuePairs|value=AnnotationValue)?
// ")"
protected class AnnotationParameters_Group extends GroupToken {
	
	public AnnotationParameters_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_RightParenthesisKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationParametersRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {AnnotationParameters}
protected class AnnotationParameters_AnnotationParametersAction_0 extends ActionToken  {

	public AnnotationParameters_AnnotationParametersAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getAnnotationParametersAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationParametersAccess().getAnnotationParametersAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "("
protected class AnnotationParameters_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public AnnotationParameters_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_AnnotationParametersAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (valuePair=AnnotationValuePairs|value=AnnotationValue)?
protected class AnnotationParameters_Alternatives_2 extends AlternativesToken {

	public AnnotationParameters_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_ValuePairAssignment_2_0(parent, this, 0, inst);
			case 1: return new AnnotationParameters_ValueAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// valuePair=AnnotationValuePairs
protected class AnnotationParameters_ValuePairAssignment_2_0 extends AssignmentToken  {
	
	public AnnotationParameters_ValuePairAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getValuePairAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePairs_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("valuePair",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("valuePair");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValuePairsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationParametersAccess().getValuePairAnnotationValuePairsParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AnnotationParameters_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// value=AnnotationValue
protected class AnnotationParameters_ValueAssignment_2_1 extends AssignmentToken  {
	
	public AnnotationParameters_ValueAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getValueAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_LeftParenthesisKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getAnnotationParametersAccess().getValueAnnotationValueParserRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}


// ")"
protected class AnnotationParameters_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public AnnotationParameters_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_Alternatives_2(parent, this, 0, inst);
			case 1: return new AnnotationParameters_LeftParenthesisKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule AnnotationParameters ****************/


/************ begin Rule AnnotationValuePairs ****************
 *
 * AnnotationValuePairs:
 *   first=AnnotationValuePair ("," listValue+=AnnotationValuePair)*;
 *
 **/

// first=AnnotationValuePair ("," listValue+=AnnotationValuePair)*
protected class AnnotationValuePairs_Group extends GroupToken {
	
	public AnnotationValuePairs_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePairs_Group_1(parent, this, 0, inst);
			case 1: return new AnnotationValuePairs_FirstAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationValuePairsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// first=AnnotationValuePair
protected class AnnotationValuePairs_FirstAssignment_0 extends AssignmentToken  {
	
	public AnnotationValuePairs_FirstAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getFirstAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePair_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("first",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("first");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValuePairRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationValuePairsAccess().getFirstAnnotationValuePairParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," listValue+=AnnotationValuePair)*
protected class AnnotationValuePairs_Group_1 extends GroupToken {
	
	public AnnotationValuePairs_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePairs_ListValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class AnnotationValuePairs_CommaKeyword_1_0 extends KeywordToken  {
	
	public AnnotationValuePairs_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePairs_Group_1(parent, this, 0, inst);
			case 1: return new AnnotationValuePairs_FirstAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// listValue+=AnnotationValuePair
protected class AnnotationValuePairs_ListValueAssignment_1_1 extends AssignmentToken  {
	
	public AnnotationValuePairs_ListValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getListValueAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePair_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("listValue",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("listValue");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValuePairRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationValuePairsAccess().getListValueAnnotationValuePairParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AnnotationValuePairs_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AnnotationValuePairs ****************/


/************ begin Rule AnnotationValuePair ****************
 *
 * AnnotationValuePair:
 *   id=ID "=" value=AnnotationValue;
 *
 **/

// id=ID "=" value=AnnotationValue
protected class AnnotationValuePair_Group extends GroupToken {
	
	public AnnotationValuePair_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationValuePairAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePair_ValueAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationValuePairRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// id=ID
protected class AnnotationValuePair_IdAssignment_0 extends AssignmentToken  {
	
	public AnnotationValuePair_IdAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationValuePairAccess().getIdAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAnnotationValuePairAccess().getIdIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "="
protected class AnnotationValuePair_EqualsSignKeyword_1 extends KeywordToken  {
	
	public AnnotationValuePair_EqualsSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationValuePairAccess().getEqualsSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePair_IdAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// value=AnnotationValue
protected class AnnotationValuePair_ValueAssignment_2 extends AssignmentToken  {
	
	public AnnotationValuePair_ValueAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationValuePairAccess().getValueAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePair_EqualsSignKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getAnnotationValuePairAccess().getValueAnnotationValueParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule AnnotationValuePair ****************/


}
