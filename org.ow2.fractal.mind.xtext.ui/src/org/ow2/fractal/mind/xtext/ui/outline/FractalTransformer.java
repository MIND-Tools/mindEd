/*
 * generated by Xtext
 */
package org.ow2.fractal.mind.xtext.ui.outline;

import java.util.List;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.ui.editor.outline.ContentOutlineNode;
import org.eclipse.xtext.ui.editor.outline.transformer.AbstractDeclarativeSemanticModelTransformer;

import adl.AdlDefinition;
import adl.ArchitectureDefinition;
import adl.BindingDefinition;
import adl.Body;
import adl.DataDefinition;
import adl.ImplementationDefinition;
import adl.SubComponentDefinition;
import adl.SubComponentPrimitiveBody;

/**
 * customization of the default outline structure
 * 
 */
public class FractalTransformer extends
		AbstractDeclarativeSemanticModelTransformer {
	
	
	// -----------------------//
	// Customize Nodes label  //
	// -----------------------//
	

	/**
	 * Customize outline label for Body object
	 * 
	 * @param obj
	 *            - model object
	 * @param parentNode
	 *            - parent node
	 * @return Custom node for the Outline view
	 */

	public ContentOutlineNode createNode(Body obj, ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(obj, parentNode);
		node.setLabel("Component Body");
		return node;
	}

	/**
	 * Customize outline label for SubComponentDefinition object
	 * 
	 * @param obj
	 * @param parentNode
	 * @return
	 */

	public ContentOutlineNode createNode(SubComponentDefinition obj,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(obj, parentNode);

		String componentType = "";

		if (obj.getBody() instanceof SubComponentPrimitiveBody)
			componentType = "Primitive";
		else
			componentType = "Composite";

		node.setLabel(componentType + " " + obj.getSimpleName());
		return node;
	}

	/**
	 * Customize outline label for ImplementationDefinition object
	 * 
	 * @param obj
	 * @param parentNode
	 * @return
	 */

	public ContentOutlineNode createNode(ImplementationDefinition obj,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(obj, parentNode);

		node.setLabel("Implementation " + obj.getFileC().getFileName());
		return node;
	}

	/**
	 * Customize outline label for DataDefinition object
	 * 
	 * @param obj
	 * @param parentNode
	 * @return
	 */

	public ContentOutlineNode createNode(DataDefinition obj,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(obj, parentNode);

		node.setLabel("Data " + obj.getFileC().getFileName());
		return node;
	}
	
	/**
	 * Customize outline label for BindingDefinition object
	 * 
	 * @param obj
	 * @param parentNode
	 * @return
	 */

	public ContentOutlineNode createNode(BindingDefinition obj,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(obj, parentNode);
		
		node.setLabel(obj.getInterfaceSourceName() + " <-> " + obj.getInterfaceTargetName());
		return node;
	}
	
	
	/**
	 * Customize outline label for AdlDefinition object
	 * 
	 * @param obj
	 * @param parentNode
	 * @return
	 */

	public ContentOutlineNode createNode(AdlDefinition obj,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(obj, parentNode);
		node.setLabel("Fractal Adl Definition");
		return node;
	}
	
	
	// --------------------------//
	// Customize Children nodes  //
	// --------------------------//

	public List<EObject> getChildren(DataDefinition obj) {
		return NO_CHILDREN;
	}

	public List<EObject> getChildren(ImplementationDefinition obj) {
		return NO_CHILDREN;
	}
	
	/**
	 * Remove Body elements in outline view
	 * 
	 * @param obj
	 * @return
	 */

	public List<EObject> getChildren(ArchitectureDefinition obj) {

		// Create a new List
		EList<EObject> list = new BasicEList<EObject>();

		// Retrieve contents of an InterfaceDefinition Element
		EList<EObject> content = obj.eContents();

		for (EObject eObject : content) {
			// If it is a 'Body' EObject then ignore
			// But add Annotations child the the list
			if (eObject instanceof Body) {
				Body annotation = (Body) eObject;
				for (EObject eObjectContent : annotation.eContents()) {
					list.add(eObjectContent);
				}
			} else
				// else add curent eObject
				list.add(eObject);
		}

		return list;

	}
	
}
