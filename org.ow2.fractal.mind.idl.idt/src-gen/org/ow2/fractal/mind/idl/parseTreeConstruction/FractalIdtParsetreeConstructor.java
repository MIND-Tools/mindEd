/*
* generated by Xtext
*/
package org.ow2.fractal.mind.idl.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.ow2.fractal.mind.idl.services.FractalIdtGrammarAccess;

import com.google.inject.Inject;

public class FractalIdtParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private FractalIdtGrammarAccess grammarAccess;
	
	@Override	
	public FractalIdtGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdtFile_Group(this, this, 0, inst);
			case 1: return new ConstantDefinitionBegin_Group(this, this, 1, inst);
			case 2: return new ConstantDefinitionEnd_Group(this, this, 2, inst);
			case 3: return new ItfFile_Group(this, this, 3, inst);
			case 4: return new TypeDefinition_Group(this, this, 4, inst);
			case 5: return new TypedefSpecification_Group(this, this, 5, inst);
			case 6: return new QualifiedTypeSpecification_Group(this, this, 6, inst);
			case 7: return new TypeSpecification_Alternatives(this, this, 7, inst);
			case 8: return new StructOrUnionSpecification_Alternatives(this, this, 8, inst);
			case 9: return new StructOrUnionDefinition_Group(this, this, 9, inst);
			case 10: return new StructorUnionReference_Group(this, this, 10, inst);
			case 11: return new StructMember_Group(this, this, 11, inst);
			case 12: return new EnumSpecification_Alternatives(this, this, 12, inst);
			case 13: return new EnumDefinition_Group(this, this, 13, inst);
			case 14: return new EnumReference_Group(this, this, 14, inst);
			case 15: return new EnumMemberList_Group(this, this, 15, inst);
			case 16: return new EnumMember_Group(this, this, 16, inst);
			case 17: return new Declarators_Group(this, this, 17, inst);
			case 18: return new Declarator_Group(this, this, 18, inst);
			case 19: return new PointerSpecification_Group(this, this, 19, inst);
			case 20: return new Qualified_PointerSpecification_Group(this, this, 20, inst);
			case 21: return new DirectDeclarator_Group(this, this, 21, inst);
			case 22: return new ArraySpecification_Group(this, this, 22, inst);
			case 23: return new ConstantDefinition_Group(this, this, 23, inst);
			case 24: return new InterfaceDefinition_Group(this, this, 24, inst);
			case 25: return new MethodDefinition_Group(this, this, 25, inst);
			case 26: return new ParameterList_Group(this, this, 26, inst);
			case 27: return new Parameter_Group(this, this, 27, inst);
			case 28: return new IncludeDirective_Group(this, this, 28, inst);
			case 29: return new Annotations_Group(this, this, 29, inst);
			case 30: return new Annotation_Group(this, this, 30, inst);
			case 31: return new AnnotationParameters_Group(this, this, 31, inst);
			case 32: return new AnnotationValuePairs_Group(this, this, 32, inst);
			case 33: return new AnnotationValuePair_Group(this, this, 33, inst);
			case 34: return new AnnotationValue_Alternatives(this, this, 34, inst);
			case 35: return new ArrayAnnotationValue_Group(this, this, 35, inst);
			case 36: return new ConstantExpression_LogicalOrExpressionParserRuleCall(this, this, 36, inst);
			case 37: return new LogicalOrExpression_Group(this, this, 37, inst);
			case 38: return new LogicalAndExpression_Group(this, this, 38, inst);
			case 39: return new OrExpression_Group(this, this, 39, inst);
			case 40: return new XorExpression_Group(this, this, 40, inst);
			case 41: return new AndExpression_Group(this, this, 41, inst);
			case 42: return new ShiftExpression_Group(this, this, 42, inst);
			case 43: return new AdditiveExpression_Group(this, this, 43, inst);
			case 44: return new MulExpression_Group(this, this, 44, inst);
			case 45: return new CastExpression_Alternatives(this, this, 45, inst);
			case 46: return new UnaryExpression_Group(this, this, 46, inst);
			case 47: return new PrimaryExpression_Alternatives(this, this, 47, inst);
			case 48: return new Literal_Alternatives(this, this, 48, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule IdtFile ****************
 *
 * IdtFile:
 *   begindef=ConstantDefinitionBegin def=ConstantDefinition includes+=IncludeDirective
 *   * (constant+=ConstantDefinition|type+=TypeDefinition)* enddef=
 *   ConstantDefinitionEnd;
 *
 **/

// begindef=ConstantDefinitionBegin def=ConstantDefinition includes+=IncludeDirective
// * (constant+=ConstantDefinition|type+=TypeDefinition)* enddef=
// ConstantDefinitionEnd
protected class IdtFile_Group extends GroupToken {
	
	public IdtFile_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdtFile_EnddefAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIdtFileRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// begindef=ConstantDefinitionBegin
protected class IdtFile_BegindefAssignment_0 extends AssignmentToken  {
	
	public IdtFile_BegindefAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getBegindefAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinitionBegin_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("begindef",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("begindef");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantDefinitionBeginRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdtFileAccess().getBegindefConstantDefinitionBeginParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// def=ConstantDefinition
protected class IdtFile_DefAssignment_1 extends AssignmentToken  {
	
	public IdtFile_DefAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getDefAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("def",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("def");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdtFileAccess().getDefConstantDefinitionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IdtFile_BegindefAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// includes+=IncludeDirective*
protected class IdtFile_IncludesAssignment_2 extends AssignmentToken  {
	
	public IdtFile_IncludesAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getIncludesAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("includes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("includes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIncludeDirectiveRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdtFileAccess().getIncludesIncludeDirectiveParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IdtFile_IncludesAssignment_2(parent, next, actIndex, consumed);
			case 1: return new IdtFile_DefAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// (constant+=ConstantDefinition|type+=TypeDefinition)*
protected class IdtFile_Alternatives_3 extends AlternativesToken {

	public IdtFile_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getAlternatives_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdtFile_ConstantAssignment_3_0(parent, this, 0, inst);
			case 1: return new IdtFile_TypeAssignment_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// constant+=ConstantDefinition
protected class IdtFile_ConstantAssignment_3_0 extends AssignmentToken  {
	
	public IdtFile_ConstantAssignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getConstantAssignment_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("constant",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("constant");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdtFileAccess().getConstantConstantDefinitionParserRuleCall_3_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IdtFile_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new IdtFile_IncludesAssignment_2(parent, next, actIndex, consumed);
			case 2: return new IdtFile_DefAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// type+=TypeDefinition
protected class IdtFile_TypeAssignment_3_1 extends AssignmentToken  {
	
	public IdtFile_TypeAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getTypeAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdtFileAccess().getTypeTypeDefinitionParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IdtFile_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new IdtFile_IncludesAssignment_2(parent, next, actIndex, consumed);
			case 2: return new IdtFile_DefAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// enddef=ConstantDefinitionEnd
protected class IdtFile_EnddefAssignment_4 extends AssignmentToken  {
	
	public IdtFile_EnddefAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getEnddefAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinitionEnd_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("enddef",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("enddef");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantDefinitionEndRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdtFileAccess().getEnddefConstantDefinitionEndParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IdtFile_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new IdtFile_IncludesAssignment_2(parent, next, actIndex, consumed);
			case 2: return new IdtFile_DefAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule IdtFile ****************/


/************ begin Rule ConstantDefinitionBegin ****************
 *
 * ConstantDefinitionBegin:
 *   "#ifndef" id=ID;
 *
 **/

// "#ifndef" id=ID
protected class ConstantDefinitionBegin_Group extends GroupToken {
	
	public ConstantDefinitionBegin_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstantDefinitionBeginAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinitionBegin_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstantDefinitionBeginRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "#ifndef"
protected class ConstantDefinitionBegin_IfndefKeyword_0 extends KeywordToken  {
	
	public ConstantDefinitionBegin_IfndefKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstantDefinitionBeginAccess().getIfndefKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID
protected class ConstantDefinitionBegin_IdAssignment_1 extends AssignmentToken  {
	
	public ConstantDefinitionBegin_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstantDefinitionBeginAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinitionBegin_IfndefKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getConstantDefinitionBeginAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule ConstantDefinitionBegin ****************/


/************ begin Rule ConstantDefinitionEnd ****************
 *
 * ConstantDefinitionEnd:
 *   "#endif" id=ID;
 *
 **/

// "#endif" id=ID
protected class ConstantDefinitionEnd_Group extends GroupToken {
	
	public ConstantDefinitionEnd_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstantDefinitionEndAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinitionEnd_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstantDefinitionEndRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "#endif"
protected class ConstantDefinitionEnd_EndifKeyword_0 extends KeywordToken  {
	
	public ConstantDefinitionEnd_EndifKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstantDefinitionEndAccess().getEndifKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID
protected class ConstantDefinitionEnd_IdAssignment_1 extends AssignmentToken  {
	
	public ConstantDefinitionEnd_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstantDefinitionEndAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinitionEnd_EndifKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getConstantDefinitionEndAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule ConstantDefinitionEnd ****************/


/************ begin Rule ItfFile ****************
 *
 * ItfFile:
 *   includes+=IncludeDirective* (constant+=ConstantDefinition|type+=TypeDefinition)*
 *   interface=InterfaceDefinition ";"?;   // itf definition
 * 
 * 
 * 
 *     
 *         // Type definition part
 *
 **/

// includes+=IncludeDirective* (constant+=ConstantDefinition|type+=TypeDefinition)*
// interface=InterfaceDefinition ";"?
protected class ItfFile_Group extends GroupToken {
	
	public ItfFile_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getItfFileAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ItfFile_InterfaceAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getItfFileRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// includes+=IncludeDirective*
protected class ItfFile_IncludesAssignment_0 extends AssignmentToken  {
	
	public ItfFile_IncludesAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getIncludesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("includes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("includes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIncludeDirectiveRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getIncludesIncludeDirectiveParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// (constant+=ConstantDefinition|type+=TypeDefinition)*
protected class ItfFile_Alternatives_1 extends AlternativesToken {

	public ItfFile_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getItfFileAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ItfFile_ConstantAssignment_1_0(parent, this, 0, inst);
			case 1: return new ItfFile_TypeAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// constant+=ConstantDefinition
protected class ItfFile_ConstantAssignment_1_0 extends AssignmentToken  {
	
	public ItfFile_ConstantAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getConstantAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("constant",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("constant");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getConstantConstantDefinitionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// type+=TypeDefinition
protected class ItfFile_TypeAssignment_1_1 extends AssignmentToken  {
	
	public ItfFile_TypeAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getTypeTypeDefinitionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}


// interface=InterfaceDefinition
protected class ItfFile_InterfaceAssignment_2 extends AssignmentToken  {
	
	public ItfFile_InterfaceAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getInterfaceAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("interface",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("interface");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInterfaceDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getInterfaceInterfaceDefinitionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}


/************ end Rule ItfFile ****************/


/************ begin Rule TypeDefinition ****************
 *
 * TypeDefinition:
 *   (TypedefSpecification|StructOrUnionSpecification|EnumSpecification) ";";   // Type definition part
 *
 **/

// (TypedefSpecification|StructOrUnionSpecification|EnumSpecification) ";"
protected class TypeDefinition_Group extends GroupToken {
	
	public TypeDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_SemicolonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TypedefSpecification|StructOrUnionSpecification|EnumSpecification
protected class TypeDefinition_Alternatives_0 extends AlternativesToken {

	public TypeDefinition_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_TypedefSpecificationParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new TypeDefinition_StructOrUnionSpecificationParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new TypeDefinition_EnumSpecificationParserRuleCall_0_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// TypedefSpecification
protected class TypeDefinition_TypedefSpecificationParserRuleCall_0_0 extends RuleCallToken {
	
	public TypeDefinition_TypedefSpecificationParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getTypedefSpecificationParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypedefSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypedefSpecification_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypedefSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StructOrUnionSpecification
protected class TypeDefinition_StructOrUnionSpecificationParserRuleCall_0_1 extends RuleCallToken {
	
	public TypeDefinition_StructOrUnionSpecificationParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getStructOrUnionSpecificationParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructOrUnionSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumSpecification
protected class TypeDefinition_EnumSpecificationParserRuleCall_0_2 extends RuleCallToken {
	
	public TypeDefinition_EnumSpecificationParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getEnumSpecificationParserRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


// ";"
protected class TypeDefinition_SemicolonKeyword_1 extends KeywordToken  {
	
	public TypeDefinition_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getSemicolonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule TypeDefinition ****************/


/************ begin Rule TypedefSpecification ****************
 *
 * TypedefSpecification:
 *   "typedef" qualifedType=QualifiedTypeSpecification dec=Declarators;
 *
 **/

// "typedef" qualifedType=QualifiedTypeSpecification dec=Declarators
protected class TypedefSpecification_Group extends GroupToken {
	
	public TypedefSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypedefSpecification_DecAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypedefSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "typedef"
protected class TypedefSpecification_TypedefKeyword_0 extends KeywordToken  {
	
	public TypedefSpecification_TypedefKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getTypedefKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// qualifedType=QualifiedTypeSpecification
protected class TypedefSpecification_QualifedTypeAssignment_1 extends AssignmentToken  {
	
	public TypedefSpecification_QualifedTypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getQualifedTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifedType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifedType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypedefSpecificationAccess().getQualifedTypeQualifiedTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypedefSpecification_TypedefKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// dec=Declarators
protected class TypedefSpecification_DecAssignment_2 extends AssignmentToken  {
	
	public TypedefSpecification_DecAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getDecAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypedefSpecificationAccess().getDecDeclaratorsParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypedefSpecification_QualifedTypeAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule TypedefSpecification ****************/


/************ begin Rule QualifiedTypeSpecification ****************
 *
 * QualifiedTypeSpecification:
 *   typeQualifier+=TypeQualifier* typeSpec=TypeSpecification;
 *
 **/

// typeQualifier+=TypeQualifier* typeSpec=TypeSpecification
protected class QualifiedTypeSpecification_Group extends GroupToken {
	
	public QualifiedTypeSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQualifiedTypeSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_TypeSpecAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// typeQualifier+=TypeQualifier*
protected class QualifiedTypeSpecification_TypeQualifierAssignment_0 extends AssignmentToken  {
	
	public QualifiedTypeSpecification_TypeQualifierAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQualifiedTypeSpecificationAccess().getTypeQualifierAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_TypeQualifierAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeQualifier",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeQualifier");
		if(Boolean.TRUE.booleanValue()) {  
			type = AssignmentType.ERC;
			element = grammarAccess.getQualifiedTypeSpecificationAccess().getTypeQualifierTypeQualifierEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// typeSpec=TypeSpecification
protected class QualifiedTypeSpecification_TypeSpecAssignment_1 extends AssignmentToken  {
	
	public QualifiedTypeSpecification_TypeSpecAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQualifiedTypeSpecificationAccess().getTypeSpecAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeSpec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeSpec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getQualifiedTypeSpecificationAccess().getTypeSpecTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new QualifiedTypeSpecification_TypeQualifierAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}


/************ end Rule QualifiedTypeSpecification ****************/


/************ begin Rule TypeSpecification ****************
 *
 * TypeSpecification:
 *   typeDefName=TypedefName|StructOrUnionSpecification|EnumSpecification|
 *   typeSpecifier+=TypeSpecifier+;
 *
 **/

// typeDefName=TypedefName|StructOrUnionSpecification|EnumSpecification|
// typeSpecifier+=TypeSpecifier+
protected class TypeSpecification_Alternatives extends AlternativesToken {

	public TypeSpecification_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeSpecification_TypeDefNameAssignment_0(parent, this, 0, inst);
			case 1: return new TypeSpecification_StructOrUnionSpecificationParserRuleCall_1(parent, this, 1, inst);
			case 2: return new TypeSpecification_EnumSpecificationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new TypeSpecification_TypeSpecifierAssignment_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// typeDefName=TypedefName
protected class TypeSpecification_TypeDefNameAssignment_0 extends AssignmentToken  {
	
	public TypeSpecification_TypeDefNameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getTypeDefNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeDefName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeDefName");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getTypeSpecificationAccess().getTypeDefNameTypedefNameParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// StructOrUnionSpecification
protected class TypeSpecification_StructOrUnionSpecificationParserRuleCall_1 extends RuleCallToken {
	
	public TypeSpecification_StructOrUnionSpecificationParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getStructOrUnionSpecificationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructOrUnionSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumSpecification
protected class TypeSpecification_EnumSpecificationParserRuleCall_2 extends RuleCallToken {
	
	public TypeSpecification_EnumSpecificationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getEnumSpecificationParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// typeSpecifier+=TypeSpecifier+
protected class TypeSpecification_TypeSpecifierAssignment_3 extends AssignmentToken  {
	
	public TypeSpecification_TypeSpecifierAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getTypeSpecifierAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeSpecification_TypeSpecifierAssignment_3(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeSpecifier",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeSpecifier");
		if(Boolean.TRUE.booleanValue()) {  
			type = AssignmentType.ERC;
			element = grammarAccess.getTypeSpecificationAccess().getTypeSpecifierTypeSpecifierEnumRuleCall_3_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule TypeSpecification ****************/



/************ begin Rule StructOrUnionSpecification ****************
 *
 * StructOrUnionSpecification:
 *   StructOrUnionDefinition|StructorUnionReference;
 *
 **/

// StructOrUnionDefinition|StructorUnionReference
protected class StructOrUnionSpecification_Alternatives extends AlternativesToken {

	public StructOrUnionSpecification_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getStructOrUnionSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionSpecification_StructOrUnionDefinitionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new StructOrUnionSpecification_StructorUnionReferenceParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// StructOrUnionDefinition
protected class StructOrUnionSpecification_StructOrUnionDefinitionParserRuleCall_0 extends RuleCallToken {
	
	public StructOrUnionSpecification_StructOrUnionDefinitionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructOrUnionSpecificationAccess().getStructOrUnionDefinitionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructOrUnionDefinition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionDefinitionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StructorUnionReference
protected class StructOrUnionSpecification_StructorUnionReferenceParserRuleCall_1 extends RuleCallToken {
	
	public StructOrUnionSpecification_StructorUnionReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructOrUnionSpecificationAccess().getStructorUnionReferenceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructorUnionReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructorUnionReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructorUnionReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule StructOrUnionSpecification ****************/


/************ begin Rule StructOrUnionDefinition ****************
 *
 * StructOrUnionDefinition:
 *   struct=StructOrUnion id=ID? "{" structMember+=StructMember* "}";
 *
 **/

// struct=StructOrUnion id=ID? "{" structMember+=StructMember* "}"
protected class StructOrUnionDefinition_Group extends GroupToken {
	
	public StructOrUnionDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// struct=StructOrUnion
protected class StructOrUnionDefinition_StructAssignment_0 extends AssignmentToken  {
	
	public StructOrUnionDefinition_StructAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getStructAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("struct",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("struct");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getStructOrUnionDefinitionAccess().getStructStructOrUnionParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// id=ID?
protected class StructOrUnionDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public StructOrUnionDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_StructAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getStructOrUnionDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class StructOrUnionDefinition_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public StructOrUnionDefinition_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_IdAssignment_1(parent, this, 0, inst);
			case 1: return new StructOrUnionDefinition_StructAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// structMember+=StructMember*
protected class StructOrUnionDefinition_StructMemberAssignment_3 extends AssignmentToken  {
	
	public StructOrUnionDefinition_StructMemberAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getStructMemberAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("structMember",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("structMember");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStructMemberRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructOrUnionDefinitionAccess().getStructMemberStructMemberParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StructOrUnionDefinition_StructMemberAssignment_3(parent, next, actIndex, consumed);
			case 1: return new StructOrUnionDefinition_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class StructOrUnionDefinition_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public StructOrUnionDefinition_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_StructMemberAssignment_3(parent, this, 0, inst);
			case 1: return new StructOrUnionDefinition_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule StructOrUnionDefinition ****************/


/************ begin Rule StructorUnionReference ****************
 *
 * StructorUnionReference:
 *   struct=StructOrUnion id=ID;
 *
 **/

// struct=StructOrUnion id=ID
protected class StructorUnionReference_Group extends GroupToken {
	
	public StructorUnionReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructorUnionReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructorUnionReference_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructorUnionReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// struct=StructOrUnion
protected class StructorUnionReference_StructAssignment_0 extends AssignmentToken  {
	
	public StructorUnionReference_StructAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructorUnionReferenceAccess().getStructAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("struct",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("struct");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getStructorUnionReferenceAccess().getStructStructOrUnionParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// id=ID
protected class StructorUnionReference_IdAssignment_1 extends AssignmentToken  {
	
	public StructorUnionReference_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructorUnionReferenceAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructorUnionReference_StructAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getStructorUnionReferenceAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule StructorUnionReference ****************/



/************ begin Rule StructMember ****************
 *
 * StructMember:
 *   annotations=Annotations qualType=QualifiedTypeSpecification dec=Declarators (":"
 *   constExpr=ConstantExpression)? ";";
 *
 **/

// annotations=Annotations qualType=QualifiedTypeSpecification dec=Declarators (":"
// constExpr=ConstantExpression)? ";"
protected class StructMember_Group extends GroupToken {
	
	public StructMember_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_SemicolonKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructMemberRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class StructMember_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public StructMember_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructMemberAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// qualType=QualifiedTypeSpecification
protected class StructMember_QualTypeAssignment_1 extends AssignmentToken  {
	
	public StructMember_QualTypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getQualTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructMemberAccess().getQualTypeQualifiedTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StructMember_AnnotationsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// dec=Declarators
protected class StructMember_DecAssignment_2 extends AssignmentToken  {
	
	public StructMember_DecAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getDecAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructMemberAccess().getDecDeclaratorsParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StructMember_QualTypeAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// (":" constExpr=ConstantExpression)?
protected class StructMember_Group_3 extends GroupToken {
	
	public StructMember_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_ConstExprAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class StructMember_ColonKeyword_3_0 extends KeywordToken  {
	
	public StructMember_ColonKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getColonKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_DecAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// constExpr=ConstantExpression
protected class StructMember_ConstExprAssignment_3_1 extends AssignmentToken  {
	
	public StructMember_ConstExprAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getConstExprAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantExpression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("constExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("constExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructMemberAccess().getConstExprConstantExpressionParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StructMember_ColonKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ";"
protected class StructMember_SemicolonKeyword_4 extends KeywordToken  {
	
	public StructMember_SemicolonKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getSemicolonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_Group_3(parent, this, 0, inst);
			case 1: return new StructMember_DecAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule StructMember ****************/


/************ begin Rule EnumSpecification ****************
 *
 * EnumSpecification:
 *   EnumDefinition|EnumReference;
 *
 **/

// EnumDefinition|EnumReference
protected class EnumSpecification_Alternatives extends AlternativesToken {

	public EnumSpecification_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEnumSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumSpecification_EnumDefinitionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new EnumSpecification_EnumReferenceParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// EnumDefinition
protected class EnumSpecification_EnumDefinitionParserRuleCall_0 extends RuleCallToken {
	
	public EnumSpecification_EnumDefinitionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumSpecificationAccess().getEnumDefinitionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumDefinition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumDefinitionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumReference
protected class EnumSpecification_EnumReferenceParserRuleCall_1 extends RuleCallToken {
	
	public EnumSpecification_EnumReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumSpecificationAccess().getEnumReferenceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule EnumSpecification ****************/


/************ begin Rule EnumDefinition ****************
 *
 * EnumDefinition:
 *   "enum" id=ID? "{" enumMemberList=EnumMemberList "}";
 *
 **/

// "enum" id=ID? "{" enumMemberList=EnumMemberList "}"
protected class EnumDefinition_Group extends GroupToken {
	
	public EnumDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "enum"
protected class EnumDefinition_EnumKeyword_0 extends KeywordToken  {
	
	public EnumDefinition_EnumKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getEnumKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID?
protected class EnumDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public EnumDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_EnumKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class EnumDefinition_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public EnumDefinition_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_IdAssignment_1(parent, this, 0, inst);
			case 1: return new EnumDefinition_EnumKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// enumMemberList=EnumMemberList
protected class EnumDefinition_EnumMemberListAssignment_3 extends AssignmentToken  {
	
	public EnumDefinition_EnumMemberListAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getEnumMemberListAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("enumMemberList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("enumMemberList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumMemberListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumDefinitionAccess().getEnumMemberListEnumMemberListParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumDefinition_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class EnumDefinition_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public EnumDefinition_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_EnumMemberListAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule EnumDefinition ****************/


/************ begin Rule EnumReference ****************
 *
 * EnumReference:
 *   "enum" id=ID;
 *
 **/

// "enum" id=ID
protected class EnumReference_Group extends GroupToken {
	
	public EnumReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumReference_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "enum"
protected class EnumReference_EnumKeyword_0 extends KeywordToken  {
	
	public EnumReference_EnumKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumReferenceAccess().getEnumKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID
protected class EnumReference_IdAssignment_1 extends AssignmentToken  {
	
	public EnumReference_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumReferenceAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumReference_EnumKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumReferenceAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule EnumReference ****************/


/************ begin Rule EnumMemberList ****************
 *
 * EnumMemberList:
 *   EnumMember ("," enumMember+=EnumMember)*;
 *
 **/

// EnumMember ("," enumMember+=EnumMember)*
protected class EnumMemberList_Group extends GroupToken {
	
	public EnumMemberList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_Group_1(parent, this, 0, inst);
			case 1: return new EnumMemberList_EnumMemberParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumMemberListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// EnumMember
protected class EnumMemberList_EnumMemberParserRuleCall_0 extends RuleCallToken {
	
	public EnumMemberList_EnumMemberParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getEnumMemberParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumMember_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumMemberRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ("," enumMember+=EnumMember)*
protected class EnumMemberList_Group_1 extends GroupToken {
	
	public EnumMemberList_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_EnumMemberAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class EnumMemberList_CommaKeyword_1_0 extends KeywordToken  {
	
	public EnumMemberList_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_Group_1(parent, this, 0, inst);
			case 1: return new EnumMemberList_EnumMemberParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// enumMember+=EnumMember
protected class EnumMemberList_EnumMemberAssignment_1_1 extends AssignmentToken  {
	
	public EnumMemberList_EnumMemberAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getEnumMemberAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("enumMember",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("enumMember");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumMemberRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumMemberListAccess().getEnumMemberEnumMemberParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumMemberList_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule EnumMemberList ****************/


/************ begin Rule EnumMember ****************
 *
 * EnumMember:
 *   annotations=Annotations id=ID ("=" constExpr=ConstantExpression)?;
 *
 **/

// annotations=Annotations id=ID ("=" constExpr=ConstantExpression)?
protected class EnumMember_Group extends GroupToken {
	
	public EnumMember_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_Group_2(parent, this, 0, inst);
			case 1: return new EnumMember_IdAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumMemberRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class EnumMember_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public EnumMember_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumMemberAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// id=ID
protected class EnumMember_IdAssignment_1 extends AssignmentToken  {
	
	public EnumMember_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_AnnotationsAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumMemberAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("=" constExpr=ConstantExpression)?
protected class EnumMember_Group_2 extends GroupToken {
	
	public EnumMember_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_ConstExprAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class EnumMember_EqualsSignKeyword_2_0 extends KeywordToken  {
	
	public EnumMember_EqualsSignKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getEqualsSignKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// constExpr=ConstantExpression
protected class EnumMember_ConstExprAssignment_2_1 extends AssignmentToken  {
	
	public EnumMember_ConstExprAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getConstExprAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantExpression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("constExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("constExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumMemberAccess().getConstExprConstantExpressionParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumMember_EqualsSignKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule EnumMember ****************/


/************ begin Rule Declarators ****************
 *
 * Declarators:
 *   dec=Declarator ("," declaratorList+=Declarator)*;
 *
 **/

// dec=Declarator ("," declaratorList+=Declarator)*
protected class Declarators_Group extends GroupToken {
	
	public Declarators_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group_1(parent, this, 0, inst);
			case 1: return new Declarators_DecAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclaratorsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// dec=Declarator
protected class Declarators_DecAssignment_0 extends AssignmentToken  {
	
	public Declarators_DecAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getDecAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorsAccess().getDecDeclaratorParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," declaratorList+=Declarator)*
protected class Declarators_Group_1 extends GroupToken {
	
	public Declarators_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_DeclaratorListAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Declarators_CommaKeyword_1_0 extends KeywordToken  {
	
	public Declarators_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group_1(parent, this, 0, inst);
			case 1: return new Declarators_DecAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// declaratorList+=Declarator
protected class Declarators_DeclaratorListAssignment_1_1 extends AssignmentToken  {
	
	public Declarators_DeclaratorListAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getDeclaratorListAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("declaratorList",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("declaratorList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorsAccess().getDeclaratorListDeclaratorParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Declarators_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Declarators ****************/


/************ begin Rule Declarator ****************
 *
 * Declarator:
 *   pointer=PointerSpecification dc=DirectDeclarator; 
 * 
 * 
 *       / *
 * AbstractDeclarator:
 *   pointer=PointerSpecification dc=AbstractDirectDeclarator;
 *   * /
 *
 **/

// pointer=PointerSpecification dc=DirectDeclarator
protected class Declarator_Group extends GroupToken {
	
	public Declarator_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_DcAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// pointer=PointerSpecification
protected class Declarator_PointerAssignment_0 extends AssignmentToken  {
	
	public Declarator_PointerAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getPointerAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PointerSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("pointer",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("pointer");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPointerSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorAccess().getPointerPointerSpecificationParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// dc=DirectDeclarator
protected class Declarator_DcAssignment_1 extends AssignmentToken  {
	
	public Declarator_DcAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getDcAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dc",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dc");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDirectDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorAccess().getDcDirectDeclaratorParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Declarator_PointerAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Declarator ****************/


/************ begin Rule PointerSpecification ****************
 *
 * PointerSpecification:
 *   {PointerSpecification} qualifiedPointer+=Qualified_PointerSpecification*;   / *
 * AbstractDeclarator:
 *   pointer=PointerSpecification dc=AbstractDirectDeclarator;
 *   * /
 *
 **/

// {PointerSpecification} qualifiedPointer+=Qualified_PointerSpecification*
protected class PointerSpecification_Group extends GroupToken {
	
	public PointerSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPointerSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PointerSpecification_QualifiedPointerAssignment_1(parent, this, 0, inst);
			case 1: return new PointerSpecification_PointerSpecificationAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPointerSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {PointerSpecification}
protected class PointerSpecification_PointerSpecificationAction_0 extends ActionToken  {

	public PointerSpecification_PointerSpecificationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPointerSpecificationAccess().getPointerSpecificationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPointerSpecificationAccess().getPointerSpecificationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// qualifiedPointer+=Qualified_PointerSpecification*
protected class PointerSpecification_QualifiedPointerAssignment_1 extends AssignmentToken  {
	
	public PointerSpecification_QualifiedPointerAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPointerSpecificationAccess().getQualifiedPointerAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Qualified_PointerSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifiedPointer",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifiedPointer");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualified_PointerSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPointerSpecificationAccess().getQualifiedPointerQualified_PointerSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PointerSpecification_QualifiedPointerAssignment_1(parent, next, actIndex, consumed);
			case 1: return new PointerSpecification_PointerSpecificationAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule PointerSpecification ****************/


/************ begin Rule Qualified_PointerSpecification ****************
 *
 * Qualified_PointerSpecification:
 *   {Qualified_PointerSpecification} "*" typeQualifier+=TypeQualifier*;
 *
 **/

// {Qualified_PointerSpecification} "*" typeQualifier+=TypeQualifier*
protected class Qualified_PointerSpecification_Group extends GroupToken {
	
	public Qualified_PointerSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQualified_PointerSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Qualified_PointerSpecification_TypeQualifierAssignment_2(parent, this, 0, inst);
			case 1: return new Qualified_PointerSpecification_AsteriskKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getQualified_PointerSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Qualified_PointerSpecification}
protected class Qualified_PointerSpecification_Qualified_PointerSpecificationAction_0 extends ActionToken  {

	public Qualified_PointerSpecification_Qualified_PointerSpecificationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getQualified_PointerSpecificationAccess().getQualified_PointerSpecificationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getQualified_PointerSpecificationAccess().getQualified_PointerSpecificationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "*"
protected class Qualified_PointerSpecification_AsteriskKeyword_1 extends KeywordToken  {
	
	public Qualified_PointerSpecification_AsteriskKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getQualified_PointerSpecificationAccess().getAsteriskKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Qualified_PointerSpecification_Qualified_PointerSpecificationAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeQualifier+=TypeQualifier*
protected class Qualified_PointerSpecification_TypeQualifierAssignment_2 extends AssignmentToken  {
	
	public Qualified_PointerSpecification_TypeQualifierAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQualified_PointerSpecificationAccess().getTypeQualifierAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Qualified_PointerSpecification_TypeQualifierAssignment_2(parent, this, 0, inst);
			case 1: return new Qualified_PointerSpecification_AsteriskKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeQualifier",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeQualifier");
		if(Boolean.TRUE.booleanValue()) {  
			type = AssignmentType.ERC;
			element = grammarAccess.getQualified_PointerSpecificationAccess().getTypeQualifierTypeQualifierEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Qualified_PointerSpecification ****************/


/************ begin Rule DirectDeclarator ****************
 *
 * DirectDeclarator:
 *   (id=ID|"(" dec=Declarator ")") array+=ArraySpecification*; 
 * 
 * 
 *           / *AbstractDirectDeclarator:
 *   '(' dec=AbstractDeclarator ')' array+=ArraySpecification*;* /
 *
 **/

// (id=ID|"(" dec=Declarator ")") array+=ArraySpecification*
protected class DirectDeclarator_Group extends GroupToken {
	
	public DirectDeclarator_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_ArrayAssignment_1(parent, this, 0, inst);
			case 1: return new DirectDeclarator_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDirectDeclaratorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// id=ID|"(" dec=Declarator ")"
protected class DirectDeclarator_Alternatives_0 extends AlternativesToken {

	public DirectDeclarator_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_IdAssignment_0_0(parent, this, 0, inst);
			case 1: return new DirectDeclarator_Group_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// id=ID
protected class DirectDeclarator_IdAssignment_0_0 extends AssignmentToken  {
	
	public DirectDeclarator_IdAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getIdAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getDirectDeclaratorAccess().getIdIDTerminalRuleCall_0_0_0();
			return obj;
		}
		return null;
	}

}

// "(" dec=Declarator ")"
protected class DirectDeclarator_Group_0_1 extends GroupToken {
	
	public DirectDeclarator_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_RightParenthesisKeyword_0_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class DirectDeclarator_LeftParenthesisKeyword_0_1_0 extends KeywordToken  {
	
	public DirectDeclarator_LeftParenthesisKeyword_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getLeftParenthesisKeyword_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// dec=Declarator
protected class DirectDeclarator_DecAssignment_0_1_1 extends AssignmentToken  {
	
	public DirectDeclarator_DecAssignment_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getDecAssignment_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDirectDeclaratorAccess().getDecDeclaratorParserRuleCall_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DirectDeclarator_LeftParenthesisKeyword_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class DirectDeclarator_RightParenthesisKeyword_0_1_2 extends KeywordToken  {
	
	public DirectDeclarator_RightParenthesisKeyword_0_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getRightParenthesisKeyword_0_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_DecAssignment_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// array+=ArraySpecification*
protected class DirectDeclarator_ArrayAssignment_1 extends AssignmentToken  {
	
	public DirectDeclarator_ArrayAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getArrayAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArraySpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("array",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("array");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getArraySpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDirectDeclaratorAccess().getArrayArraySpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DirectDeclarator_ArrayAssignment_1(parent, next, actIndex, consumed);
			case 1: return new DirectDeclarator_Alternatives_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule DirectDeclarator ****************/


/************ begin Rule ArraySpecification ****************
 *
 * ArraySpecification:
 *   "[" constExpr=ConstantExpression "]";   / *AbstractDirectDeclarator:
 *   '(' dec=AbstractDeclarator ')' array+=ArraySpecification*;* /
 *
 **/

// "[" constExpr=ConstantExpression "]"
protected class ArraySpecification_Group extends GroupToken {
	
	public ArraySpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArraySpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArraySpecification_RightSquareBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getArraySpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "["
protected class ArraySpecification_LeftSquareBracketKeyword_0 extends KeywordToken  {
	
	public ArraySpecification_LeftSquareBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArraySpecificationAccess().getLeftSquareBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// constExpr=ConstantExpression
protected class ArraySpecification_ConstExprAssignment_1 extends AssignmentToken  {
	
	public ArraySpecification_ConstExprAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getArraySpecificationAccess().getConstExprAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantExpression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("constExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("constExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getArraySpecificationAccess().getConstExprConstantExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ArraySpecification_LeftSquareBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class ArraySpecification_RightSquareBracketKeyword_2 extends KeywordToken  {
	
	public ArraySpecification_RightSquareBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArraySpecificationAccess().getRightSquareBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArraySpecification_ConstExprAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ArraySpecification ****************/



/************ begin Rule ConstantDefinition ****************
 *
 * ConstantDefinition:
 *   "#define" id=ID;   // Interface definition part
 *
 **/

// "#define" id=ID
protected class ConstantDefinition_Group extends GroupToken {
	
	public ConstantDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "#define"
protected class ConstantDefinition_DefineKeyword_0 extends KeywordToken  {
	
	public ConstantDefinition_DefineKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getDefineKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID
protected class ConstantDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public ConstantDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_DefineKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getConstantDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule ConstantDefinition ****************/


/************ begin Rule InterfaceDefinition ****************
 *
 * InterfaceDefinition:
 *   annotations=Annotations "interface" "unmanaged"? fqn=FullyQualifiedName (":" fqn2=
 *   FullyQualifiedName)? "{" methodDef+=MethodDefinition* "}";
 *
 **/

// annotations=Annotations "interface" "unmanaged"? fqn=FullyQualifiedName (":" fqn2=
// FullyQualifiedName)? "{" methodDef+=MethodDefinition* "}"
protected class InterfaceDefinition_Group extends GroupToken {
	
	public InterfaceDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_RightCurlyBracketKeyword_7(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInterfaceDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class InterfaceDefinition_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public InterfaceDefinition_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInterfaceDefinitionAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// "interface"
protected class InterfaceDefinition_InterfaceKeyword_1 extends KeywordToken  {
	
	public InterfaceDefinition_InterfaceKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getInterfaceKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_AnnotationsAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// fqn=FullyQualifiedName
protected class InterfaceDefinition_FqnAssignment_3 extends AssignmentToken  {
	
	public InterfaceDefinition_FqnAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getFqnAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_InterfaceKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fqn",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fqn");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getInterfaceDefinitionAccess().getFqnFullyQualifiedNameParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// (":" fqn2=FullyQualifiedName)?
protected class InterfaceDefinition_Group_4 extends GroupToken {
	
	public InterfaceDefinition_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_Fqn2Assignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class InterfaceDefinition_ColonKeyword_4_0 extends KeywordToken  {
	
	public InterfaceDefinition_ColonKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getColonKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_FqnAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// fqn2=FullyQualifiedName
protected class InterfaceDefinition_Fqn2Assignment_4_1 extends AssignmentToken  {
	
	public InterfaceDefinition_Fqn2Assignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getFqn2Assignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_ColonKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fqn2",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fqn2");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getInterfaceDefinitionAccess().getFqn2FullyQualifiedNameParserRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}


// "{"
protected class InterfaceDefinition_LeftCurlyBracketKeyword_5 extends KeywordToken  {
	
	public InterfaceDefinition_LeftCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getLeftCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_Group_4(parent, this, 0, inst);
			case 1: return new InterfaceDefinition_FqnAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// methodDef+=MethodDefinition*
protected class InterfaceDefinition_MethodDefAssignment_6 extends AssignmentToken  {
	
	public InterfaceDefinition_MethodDefAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getMethodDefAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("methodDef",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("methodDef");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMethodDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInterfaceDefinitionAccess().getMethodDefMethodDefinitionParserRuleCall_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InterfaceDefinition_MethodDefAssignment_6(parent, next, actIndex, consumed);
			case 1: return new InterfaceDefinition_LeftCurlyBracketKeyword_5(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class InterfaceDefinition_RightCurlyBracketKeyword_7 extends KeywordToken  {
	
	public InterfaceDefinition_RightCurlyBracketKeyword_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getRightCurlyBracketKeyword_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_MethodDefAssignment_6(parent, this, 0, inst);
			case 1: return new InterfaceDefinition_LeftCurlyBracketKeyword_5(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule InterfaceDefinition ****************/


/************ begin Rule MethodDefinition ****************
 *
 * MethodDefinition:
 *   annotations=Annotations qualifiedTypeSpec=QualifiedTypeSpecification id=ID ("("
 *   "void"? ")"|"(" ParameterList=ParameterList ")") ";";
 *
 **/

// annotations=Annotations qualifiedTypeSpec=QualifiedTypeSpecification id=ID ("("
// "void"? ")"|"(" ParameterList=ParameterList ")") ";"
protected class MethodDefinition_Group extends GroupToken {
	
	public MethodDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_SemicolonKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMethodDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class MethodDefinition_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public MethodDefinition_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethodDefinitionAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// qualifiedTypeSpec=QualifiedTypeSpecification
protected class MethodDefinition_QualifiedTypeSpecAssignment_1 extends AssignmentToken  {
	
	public MethodDefinition_QualifiedTypeSpecAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getQualifiedTypeSpecAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifiedTypeSpec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifiedTypeSpec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethodDefinitionAccess().getQualifiedTypeSpecQualifiedTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MethodDefinition_AnnotationsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// id=ID
protected class MethodDefinition_IdAssignment_2 extends AssignmentToken  {
	
	public MethodDefinition_IdAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getIdAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_QualifiedTypeSpecAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getMethodDefinitionAccess().getIdIDTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "(" "void"? ")"|"(" ParameterList=ParameterList ")"
protected class MethodDefinition_Alternatives_3 extends AlternativesToken {

	public MethodDefinition_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getAlternatives_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_Group_3_0(parent, this, 0, inst);
			case 1: return new MethodDefinition_Group_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "(" "void"? ")"
protected class MethodDefinition_Group_3_0 extends GroupToken {
	
	public MethodDefinition_Group_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getGroup_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_RightParenthesisKeyword_3_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class MethodDefinition_LeftParenthesisKeyword_3_0_0 extends KeywordToken  {
	
	public MethodDefinition_LeftParenthesisKeyword_3_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getLeftParenthesisKeyword_3_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_IdAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ")"
protected class MethodDefinition_RightParenthesisKeyword_3_0_2 extends KeywordToken  {
	
	public MethodDefinition_RightParenthesisKeyword_3_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getRightParenthesisKeyword_3_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_LeftParenthesisKeyword_3_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "(" ParameterList=ParameterList ")"
protected class MethodDefinition_Group_3_1 extends GroupToken {
	
	public MethodDefinition_Group_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getGroup_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_RightParenthesisKeyword_3_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class MethodDefinition_LeftParenthesisKeyword_3_1_0 extends KeywordToken  {
	
	public MethodDefinition_LeftParenthesisKeyword_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getLeftParenthesisKeyword_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_IdAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ParameterList=ParameterList
protected class MethodDefinition_ParameterListAssignment_3_1_1 extends AssignmentToken  {
	
	public MethodDefinition_ParameterListAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getParameterListAssignment_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ParameterList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ParameterList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethodDefinitionAccess().getParameterListParameterListParserRuleCall_3_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MethodDefinition_LeftParenthesisKeyword_3_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class MethodDefinition_RightParenthesisKeyword_3_1_2 extends KeywordToken  {
	
	public MethodDefinition_RightParenthesisKeyword_3_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getRightParenthesisKeyword_3_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_ParameterListAssignment_3_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// ";"
protected class MethodDefinition_SemicolonKeyword_4 extends KeywordToken  {
	
	public MethodDefinition_SemicolonKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getSemicolonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_Alternatives_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule MethodDefinition ****************/


/************ begin Rule ParameterList ****************
 *
 * ParameterList:
 *   param=Parameter ("," params+=Parameter)* ("," "...")?;
 *
 **/

// param=Parameter ("," params+=Parameter)* ("," "...")?
protected class ParameterList_Group extends GroupToken {
	
	public ParameterList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group_1(parent, this, 0, inst);
			case 1: return new ParameterList_ParamAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// param=Parameter
protected class ParameterList_ParamAssignment_0 extends AssignmentToken  {
	
	public ParameterList_ParamAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterListAccess().getParamAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("param",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("param");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterListAccess().getParamParameterParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," params+=Parameter)*
protected class ParameterList_Group_1 extends GroupToken {
	
	public ParameterList_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterListAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_ParamsAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ParameterList_CommaKeyword_1_0 extends KeywordToken  {
	
	public ParameterList_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParameterListAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group_1(parent, this, 0, inst);
			case 1: return new ParameterList_ParamAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Parameter
protected class ParameterList_ParamsAssignment_1_1 extends AssignmentToken  {
	
	public ParameterList_ParamsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterListAccess().getParamsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterListAccess().getParamsParameterParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ParameterList_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ParameterList ****************/


/************ begin Rule Parameter ****************
 *
 * Parameter:
 *   annotations=Annotations ParameterQualifier+=ParameterQualifier* qualifiedTypeSpec=
 *   QualifiedTypeSpecification dec=Declarator?;
 *
 **/

// annotations=Annotations ParameterQualifier+=ParameterQualifier* qualifiedTypeSpec=
// QualifiedTypeSpecification dec=Declarator?
protected class Parameter_Group extends GroupToken {
	
	public Parameter_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_DecAssignment_3(parent, this, 0, inst);
			case 1: return new Parameter_QualifiedTypeSpecAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// annotations=Annotations
protected class Parameter_AnnotationsAssignment_0 extends AssignmentToken  {
	
	public Parameter_AnnotationsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getAnnotationsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterAccess().getAnnotationsAnnotationsParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ParameterQualifier+=ParameterQualifier*
protected class Parameter_ParameterQualifierAssignment_1 extends AssignmentToken  {
	
	public Parameter_ParameterQualifierAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getParameterQualifierAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_ParameterQualifierAssignment_1(parent, this, 0, inst);
			case 1: return new Parameter_AnnotationsAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ParameterQualifier",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ParameterQualifier");
		if(Boolean.TRUE.booleanValue()) {  
			type = AssignmentType.ERC;
			element = grammarAccess.getParameterAccess().getParameterQualifierParameterQualifierEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// qualifiedTypeSpec=QualifiedTypeSpecification
protected class Parameter_QualifiedTypeSpecAssignment_2 extends AssignmentToken  {
	
	public Parameter_QualifiedTypeSpecAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getQualifiedTypeSpecAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifiedTypeSpec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifiedTypeSpec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterAccess().getQualifiedTypeSpecQualifiedTypeSpecificationParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Parameter_ParameterQualifierAssignment_1(parent, next, actIndex, consumed);
			case 1: return new Parameter_AnnotationsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// dec=Declarator?
protected class Parameter_DecAssignment_3 extends AssignmentToken  {
	
	public Parameter_DecAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getDecAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterAccess().getDecDeclaratorParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Parameter_QualifiedTypeSpecAssignment_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Parameter ****************/


/************ begin Rule IncludeDirective ****************
 *
 * IncludeDirective:
 *   "#include" (importedURI=STRING|includeID=IncludeLib);   // include directive
 *
 **/

// "#include" (importedURI=STRING|includeID=IncludeLib)
protected class IncludeDirective_Group extends GroupToken {
	
	public IncludeDirective_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIncludeDirectiveRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "#include"
protected class IncludeDirective_IncludeKeyword_0 extends KeywordToken  {
	
	public IncludeDirective_IncludeKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getIncludeKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// importedURI=STRING|includeID=IncludeLib
protected class IncludeDirective_Alternatives_1 extends AlternativesToken {

	public IncludeDirective_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_ImportedURIAssignment_1_0(parent, this, 0, inst);
			case 1: return new IncludeDirective_IncludeIDAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// importedURI=STRING
protected class IncludeDirective_ImportedURIAssignment_1_0 extends AssignmentToken  {
	
	public IncludeDirective_ImportedURIAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getImportedURIAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_IncludeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("importedURI",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("importedURI");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getIncludeDirectiveAccess().getImportedURISTRINGTerminalRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// includeID=IncludeLib
protected class IncludeDirective_IncludeIDAssignment_1_1 extends AssignmentToken  {
	
	public IncludeDirective_IncludeIDAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getIncludeIDAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_IncludeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("includeID",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("includeID");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getIncludeDirectiveAccess().getIncludeIDIncludeLibTerminalRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule IncludeDirective ****************/


/************ begin Rule Annotations ****************
 *
 * Annotations:
 *   {Annotations} annotations+=Annotation*;
 *
 **/

// {Annotations} annotations+=Annotation*
protected class Annotations_Group extends GroupToken {
	
	public Annotations_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotations_AnnotationsAssignment_1(parent, this, 0, inst);
			case 1: return new Annotations_AnnotationsAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Annotations}
protected class Annotations_AnnotationsAction_0 extends ActionToken  {

	public Annotations_AnnotationsAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAnnotationsAccess().getAnnotationsAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationsAccess().getAnnotationsAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// annotations+=Annotation*
protected class Annotations_AnnotationsAssignment_1 extends AssignmentToken  {
	
	public Annotations_AnnotationsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationsAccess().getAnnotationsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationsAccess().getAnnotationsAnnotationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Annotations_AnnotationsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new Annotations_AnnotationsAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Annotations ****************/


/************ begin Rule Annotation ****************
 *
 * Annotation:
 *   "@" fqn=FullyQualifiedName annotationParamaters=AnnotationParameters?;
 *
 **/

// "@" fqn=FullyQualifiedName annotationParamaters=AnnotationParameters?
protected class Annotation_Group extends GroupToken {
	
	public Annotation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotation_AnnotationParamatersAssignment_2(parent, this, 0, inst);
			case 1: return new Annotation_FqnAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "@"
protected class Annotation_CommercialAtKeyword_0 extends KeywordToken  {
	
	public Annotation_CommercialAtKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationAccess().getCommercialAtKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// fqn=FullyQualifiedName
protected class Annotation_FqnAssignment_1 extends AssignmentToken  {
	
	public Annotation_FqnAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationAccess().getFqnAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotation_CommercialAtKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fqn",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fqn");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAnnotationAccess().getFqnFullyQualifiedNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// annotationParamaters=AnnotationParameters?
protected class Annotation_AnnotationParamatersAssignment_2 extends AssignmentToken  {
	
	public Annotation_AnnotationParamatersAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationAccess().getAnnotationParamatersAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotationParamaters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotationParamaters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationParametersRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationAccess().getAnnotationParamatersAnnotationParametersParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Annotation_FqnAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Annotation ****************/


/************ begin Rule AnnotationParameters ****************
 *
 * AnnotationParameters:
 *   {AnnotationParameters} "(" (valuePair=AnnotationValuePairs|value=AnnotationValue)?
 *   ")";
 *
 **/

// {AnnotationParameters} "(" (valuePair=AnnotationValuePairs|value=AnnotationValue)?
// ")"
protected class AnnotationParameters_Group extends GroupToken {
	
	public AnnotationParameters_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_RightParenthesisKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationParametersRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {AnnotationParameters}
protected class AnnotationParameters_AnnotationParametersAction_0 extends ActionToken  {

	public AnnotationParameters_AnnotationParametersAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getAnnotationParametersAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationParametersAccess().getAnnotationParametersAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "("
protected class AnnotationParameters_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public AnnotationParameters_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_AnnotationParametersAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (valuePair=AnnotationValuePairs|value=AnnotationValue)?
protected class AnnotationParameters_Alternatives_2 extends AlternativesToken {

	public AnnotationParameters_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_ValuePairAssignment_2_0(parent, this, 0, inst);
			case 1: return new AnnotationParameters_ValueAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// valuePair=AnnotationValuePairs
protected class AnnotationParameters_ValuePairAssignment_2_0 extends AssignmentToken  {
	
	public AnnotationParameters_ValuePairAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getValuePairAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePairs_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("valuePair",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("valuePair");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValuePairsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationParametersAccess().getValuePairAnnotationValuePairsParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AnnotationParameters_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// value=AnnotationValue
protected class AnnotationParameters_ValueAssignment_2_1 extends AssignmentToken  {
	
	public AnnotationParameters_ValueAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getValueAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValue_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationParametersAccess().getValueAnnotationValueParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AnnotationParameters_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class AnnotationParameters_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public AnnotationParameters_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationParametersAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationParameters_Alternatives_2(parent, this, 0, inst);
			case 1: return new AnnotationParameters_LeftParenthesisKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule AnnotationParameters ****************/


/************ begin Rule AnnotationValuePairs ****************
 *
 * AnnotationValuePairs:
 *   first=AnnotationValuePair ("," listValue+=AnnotationValuePair)*;
 *
 **/

// first=AnnotationValuePair ("," listValue+=AnnotationValuePair)*
protected class AnnotationValuePairs_Group extends GroupToken {
	
	public AnnotationValuePairs_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePairs_Group_1(parent, this, 0, inst);
			case 1: return new AnnotationValuePairs_FirstAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationValuePairsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// first=AnnotationValuePair
protected class AnnotationValuePairs_FirstAssignment_0 extends AssignmentToken  {
	
	public AnnotationValuePairs_FirstAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getFirstAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePair_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("first",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("first");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValuePairRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationValuePairsAccess().getFirstAnnotationValuePairParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," listValue+=AnnotationValuePair)*
protected class AnnotationValuePairs_Group_1 extends GroupToken {
	
	public AnnotationValuePairs_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePairs_ListValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class AnnotationValuePairs_CommaKeyword_1_0 extends KeywordToken  {
	
	public AnnotationValuePairs_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePairs_Group_1(parent, this, 0, inst);
			case 1: return new AnnotationValuePairs_FirstAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// listValue+=AnnotationValuePair
protected class AnnotationValuePairs_ListValueAssignment_1_1 extends AssignmentToken  {
	
	public AnnotationValuePairs_ListValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationValuePairsAccess().getListValueAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePair_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("listValue",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("listValue");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValuePairRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationValuePairsAccess().getListValueAnnotationValuePairParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AnnotationValuePairs_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AnnotationValuePairs ****************/


/************ begin Rule AnnotationValuePair ****************
 *
 * AnnotationValuePair:
 *   id=ID "=" value=AnnotationValue;
 *
 **/

// id=ID "=" value=AnnotationValue
protected class AnnotationValuePair_Group extends GroupToken {
	
	public AnnotationValuePair_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAnnotationValuePairAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePair_ValueAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationValuePairRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// id=ID
protected class AnnotationValuePair_IdAssignment_0 extends AssignmentToken  {
	
	public AnnotationValuePair_IdAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationValuePairAccess().getIdAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getAnnotationValuePairAccess().getIdIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "="
protected class AnnotationValuePair_EqualsSignKeyword_1 extends KeywordToken  {
	
	public AnnotationValuePair_EqualsSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationValuePairAccess().getEqualsSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValuePair_IdAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// value=AnnotationValue
protected class AnnotationValuePair_ValueAssignment_2 extends AssignmentToken  {
	
	public AnnotationValuePair_ValueAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAnnotationValuePairAccess().getValueAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValue_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAnnotationValuePairAccess().getValueAnnotationValueParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AnnotationValuePair_EqualsSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule AnnotationValuePair ****************/


/************ begin Rule AnnotationValue ****************
 *
 * AnnotationValue:
 *   signedINT|"null"|Boolean|ID|Annotation|ArrayAnnotationValue|STRING;
 *
 **/

// signedINT|"null"|Boolean|ID|Annotation|ArrayAnnotationValue|STRING
protected class AnnotationValue_Alternatives extends AlternativesToken {

	public AnnotationValue_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAnnotationValueAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValue_SignedINTParserRuleCall_0(parent, this, 0, inst);
			case 1: return new AnnotationValue_NullKeyword_1(parent, this, 1, inst);
			case 2: return new AnnotationValue_BooleanTerminalRuleCall_2(parent, this, 2, inst);
			case 3: return new AnnotationValue_IDTerminalRuleCall_3(parent, this, 3, inst);
			case 4: return new AnnotationValue_AnnotationParserRuleCall_4(parent, this, 4, inst);
			case 5: return new AnnotationValue_ArrayAnnotationValueParserRuleCall_5(parent, this, 5, inst);
			case 6: return new AnnotationValue_STRINGTerminalRuleCall_6(parent, this, 6, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAnnotationValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// signedINT
protected class AnnotationValue_SignedINTParserRuleCall_0 extends UnassignedTextToken {

	public AnnotationValue_SignedINTParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAnnotationValueAccess().getSignedINTParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "null"
protected class AnnotationValue_NullKeyword_1 extends KeywordToken  {
	
	public AnnotationValue_NullKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAnnotationValueAccess().getNullKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// Boolean
protected class AnnotationValue_BooleanTerminalRuleCall_2 extends UnassignedTextToken {

	public AnnotationValue_BooleanTerminalRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAnnotationValueAccess().getBooleanTerminalRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// ID
protected class AnnotationValue_IDTerminalRuleCall_3 extends UnassignedTextToken {

	public AnnotationValue_IDTerminalRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAnnotationValueAccess().getIDTerminalRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// Annotation
protected class AnnotationValue_AnnotationParserRuleCall_4 extends RuleCallToken {
	
	public AnnotationValue_AnnotationParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAnnotationValueAccess().getAnnotationParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Annotation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Annotation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAnnotationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ArrayAnnotationValue
protected class AnnotationValue_ArrayAnnotationValueParserRuleCall_5 extends RuleCallToken {
	
	public AnnotationValue_ArrayAnnotationValueParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAnnotationValueAccess().getArrayAnnotationValueParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAnnotationValue_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ArrayAnnotationValue_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getArrayAnnotationValueRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// STRING
protected class AnnotationValue_STRINGTerminalRuleCall_6 extends UnassignedTextToken {

	public AnnotationValue_STRINGTerminalRuleCall_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAnnotationValueAccess().getSTRINGTerminalRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}


/************ end Rule AnnotationValue ****************/


/************ begin Rule ArrayAnnotationValue ****************
 *
 * ArrayAnnotationValue:
 *   "{" (firstValue=AnnotationValue ("," values+=AnnotationValue)*)? "}";
 *
 **/

// "{" (firstValue=AnnotationValue ("," values+=AnnotationValue)*)? "}"
protected class ArrayAnnotationValue_Group extends GroupToken {
	
	public ArrayAnnotationValue_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArrayAnnotationValueAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAnnotationValue_RightCurlyBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getArrayAnnotationValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "{"
protected class ArrayAnnotationValue_LeftCurlyBracketKeyword_0 extends KeywordToken  {
	
	public ArrayAnnotationValue_LeftCurlyBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArrayAnnotationValueAccess().getLeftCurlyBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// (firstValue=AnnotationValue ("," values+=AnnotationValue)*)?
protected class ArrayAnnotationValue_Group_1 extends GroupToken {
	
	public ArrayAnnotationValue_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArrayAnnotationValueAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAnnotationValue_Group_1_1(parent, this, 0, inst);
			case 1: return new ArrayAnnotationValue_FirstValueAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// firstValue=AnnotationValue
protected class ArrayAnnotationValue_FirstValueAssignment_1_0 extends AssignmentToken  {
	
	public ArrayAnnotationValue_FirstValueAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getArrayAnnotationValueAccess().getFirstValueAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValue_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("firstValue",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("firstValue");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getArrayAnnotationValueAccess().getFirstValueAnnotationValueParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ArrayAnnotationValue_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," values+=AnnotationValue)*
protected class ArrayAnnotationValue_Group_1_1 extends GroupToken {
	
	public ArrayAnnotationValue_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArrayAnnotationValueAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAnnotationValue_ValuesAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ArrayAnnotationValue_CommaKeyword_1_1_0 extends KeywordToken  {
	
	public ArrayAnnotationValue_CommaKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArrayAnnotationValueAccess().getCommaKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAnnotationValue_Group_1_1(parent, this, 0, inst);
			case 1: return new ArrayAnnotationValue_FirstValueAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// values+=AnnotationValue
protected class ArrayAnnotationValue_ValuesAssignment_1_1_1 extends AssignmentToken  {
	
	public ArrayAnnotationValue_ValuesAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getArrayAnnotationValueAccess().getValuesAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AnnotationValue_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("values",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAnnotationValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getArrayAnnotationValueAccess().getValuesAnnotationValueParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ArrayAnnotationValue_CommaKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "}"
protected class ArrayAnnotationValue_RightCurlyBracketKeyword_2 extends KeywordToken  {
	
	public ArrayAnnotationValue_RightCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArrayAnnotationValueAccess().getRightCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAnnotationValue_Group_1(parent, this, 0, inst);
			case 1: return new ArrayAnnotationValue_LeftCurlyBracketKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ArrayAnnotationValue ****************/



/************ begin Rule ConstantExpression ****************
 *
 * ConstantExpression:
 *   LogicalOrExpression;
 *
 **/

// LogicalOrExpression
protected class ConstantExpression_LogicalOrExpressionParserRuleCall extends RuleCallToken {
	
	public ConstantExpression_LogicalOrExpressionParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getConstantExpressionAccess().getLogicalOrExpressionParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstantExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LogicalOrExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLogicalOrExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule ConstantExpression ****************/


/************ begin Rule LogicalOrExpression ****************
 *
 * LogicalOrExpression:
 *   leftExpr=LogicalAndExpression ("||" rightExpr=LogicalOrExpression)?;
 *
 **/

// leftExpr=LogicalAndExpression ("||" rightExpr=LogicalOrExpression)?
protected class LogicalOrExpression_Group extends GroupToken {
	
	public LogicalOrExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalOrExpression_Group_1(parent, this, 0, inst);
			case 1: return new LogicalOrExpression_LeftExprAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLogicalOrExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// leftExpr=LogicalAndExpression
protected class LogicalOrExpression_LeftExprAssignment_0 extends AssignmentToken  {
	
	public LogicalOrExpression_LeftExprAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getLeftExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("leftExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLogicalAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLogicalOrExpressionAccess().getLeftExprLogicalAndExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("||" rightExpr=LogicalOrExpression)?
protected class LogicalOrExpression_Group_1 extends GroupToken {
	
	public LogicalOrExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalOrExpression_RightExprAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "||"
protected class LogicalOrExpression_VerticalLineVerticalLineKeyword_1_0 extends KeywordToken  {
	
	public LogicalOrExpression_VerticalLineVerticalLineKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getVerticalLineVerticalLineKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalOrExpression_LeftExprAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// rightExpr=LogicalOrExpression
protected class LogicalOrExpression_RightExprAssignment_1_1 extends AssignmentToken  {
	
	public LogicalOrExpression_RightExprAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getRightExprAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLogicalOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLogicalOrExpressionAccess().getRightExprLogicalOrExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LogicalOrExpression_VerticalLineVerticalLineKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule LogicalOrExpression ****************/


/************ begin Rule LogicalAndExpression ****************
 *
 * LogicalAndExpression:
 *   leftExpr=OrExpression ("&&" rightExpr=LogicalAndExpression)?;
 *
 **/

// leftExpr=OrExpression ("&&" rightExpr=LogicalAndExpression)?
protected class LogicalAndExpression_Group extends GroupToken {
	
	public LogicalAndExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_Group_1(parent, this, 0, inst);
			case 1: return new LogicalAndExpression_LeftExprAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLogicalAndExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// leftExpr=OrExpression
protected class LogicalAndExpression_LeftExprAssignment_0 extends AssignmentToken  {
	
	public LogicalAndExpression_LeftExprAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getLeftExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("leftExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLogicalAndExpressionAccess().getLeftExprOrExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("&&" rightExpr=LogicalAndExpression)?
protected class LogicalAndExpression_Group_1 extends GroupToken {
	
	public LogicalAndExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_RightExprAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "&&"
protected class LogicalAndExpression_AmpersandAmpersandKeyword_1_0 extends KeywordToken  {
	
	public LogicalAndExpression_AmpersandAmpersandKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getAmpersandAmpersandKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_LeftExprAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// rightExpr=LogicalAndExpression
protected class LogicalAndExpression_RightExprAssignment_1_1 extends AssignmentToken  {
	
	public LogicalAndExpression_RightExprAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getRightExprAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLogicalAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLogicalAndExpressionAccess().getRightExprLogicalAndExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LogicalAndExpression_AmpersandAmpersandKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule LogicalAndExpression ****************/


/************ begin Rule OrExpression ****************
 *
 * OrExpression:
 *   leftExpr=XorExpression ("|" rightExpr=OrExpression)?;
 *
 **/

// leftExpr=XorExpression ("|" rightExpr=OrExpression)?
protected class OrExpression_Group extends GroupToken {
	
	public OrExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group_1(parent, this, 0, inst);
			case 1: return new OrExpression_LeftExprAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// leftExpr=XorExpression
protected class OrExpression_LeftExprAssignment_0 extends AssignmentToken  {
	
	public OrExpression_LeftExprAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getLeftExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("leftExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getXorExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrExpressionAccess().getLeftExprXorExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("|" rightExpr=OrExpression)?
protected class OrExpression_Group_1 extends GroupToken {
	
	public OrExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_RightExprAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "|"
protected class OrExpression_VerticalLineKeyword_1_0 extends KeywordToken  {
	
	public OrExpression_VerticalLineKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getVerticalLineKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_LeftExprAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// rightExpr=OrExpression
protected class OrExpression_RightExprAssignment_1_1 extends AssignmentToken  {
	
	public OrExpression_RightExprAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getRightExprAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrExpressionAccess().getRightExprOrExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrExpression_VerticalLineKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrExpression ****************/


/************ begin Rule XorExpression ****************
 *
 * XorExpression:
 *   leftExpr=AndExpression ("^" rightExpr=XorExpression)?;
 *
 **/

// leftExpr=AndExpression ("^" rightExpr=XorExpression)?
protected class XorExpression_Group extends GroupToken {
	
	public XorExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorExpression_Group_1(parent, this, 0, inst);
			case 1: return new XorExpression_LeftExprAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getXorExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// leftExpr=AndExpression
protected class XorExpression_LeftExprAssignment_0 extends AssignmentToken  {
	
	public XorExpression_LeftExprAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getLeftExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("leftExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getXorExpressionAccess().getLeftExprAndExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("^" rightExpr=XorExpression)?
protected class XorExpression_Group_1 extends GroupToken {
	
	public XorExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorExpression_RightExprAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "^"
protected class XorExpression_CircumflexAccentKeyword_1_0 extends KeywordToken  {
	
	public XorExpression_CircumflexAccentKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getCircumflexAccentKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorExpression_LeftExprAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// rightExpr=XorExpression
protected class XorExpression_RightExprAssignment_1_1 extends AssignmentToken  {
	
	public XorExpression_RightExprAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getRightExprAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getXorExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getXorExpressionAccess().getRightExprXorExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new XorExpression_CircumflexAccentKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule XorExpression ****************/


/************ begin Rule AndExpression ****************
 *
 * AndExpression:
 *   leftExpr=ShiftExpression ("&" rightExpr=AndExpression)?;
 *
 **/

// leftExpr=ShiftExpression ("&" rightExpr=AndExpression)?
protected class AndExpression_Group extends GroupToken {
	
	public AndExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(parent, this, 0, inst);
			case 1: return new AndExpression_LeftExprAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// leftExpr=ShiftExpression
protected class AndExpression_LeftExprAssignment_0 extends AssignmentToken  {
	
	public AndExpression_LeftExprAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getLeftExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("leftExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getShiftExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndExpressionAccess().getLeftExprShiftExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("&" rightExpr=AndExpression)?
protected class AndExpression_Group_1 extends GroupToken {
	
	public AndExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_RightExprAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "&"
protected class AndExpression_AmpersandKeyword_1_0 extends KeywordToken  {
	
	public AndExpression_AmpersandKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getAmpersandKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_LeftExprAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// rightExpr=AndExpression
protected class AndExpression_RightExprAssignment_1_1 extends AssignmentToken  {
	
	public AndExpression_RightExprAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getRightExprAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndExpressionAccess().getRightExprAndExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndExpression_AmpersandKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndExpression ****************/


/************ begin Rule ShiftExpression ****************
 *
 * ShiftExpression:
 *   leftExpr=AdditiveExpression (op=ShiftOperation rightExpr=ShiftExpression)?;
 *
 **/

// leftExpr=AdditiveExpression (op=ShiftOperation rightExpr=ShiftExpression)?
protected class ShiftExpression_Group extends GroupToken {
	
	public ShiftExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Group_1(parent, this, 0, inst);
			case 1: return new ShiftExpression_LeftExprAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getShiftExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// leftExpr=AdditiveExpression
protected class ShiftExpression_LeftExprAssignment_0 extends AssignmentToken  {
	
	public ShiftExpression_LeftExprAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getLeftExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("leftExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getShiftExpressionAccess().getLeftExprAdditiveExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (op=ShiftOperation rightExpr=ShiftExpression)?
protected class ShiftExpression_Group_1 extends GroupToken {
	
	public ShiftExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_RightExprAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// op=ShiftOperation
protected class ShiftExpression_OpAssignment_1_0 extends AssignmentToken  {
	
	public ShiftExpression_OpAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getOpAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_LeftExprAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getShiftExpressionAccess().getOpShiftOperationParserRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// rightExpr=ShiftExpression
protected class ShiftExpression_RightExprAssignment_1_1 extends AssignmentToken  {
	
	public ShiftExpression_RightExprAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getRightExprAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getShiftExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getShiftExpressionAccess().getRightExprShiftExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ShiftExpression_OpAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ShiftExpression ****************/


/************ begin Rule AdditiveExpression ****************
 *
 * AdditiveExpression:
 *   leftExpr=MulExpression (op=AdditiveOperation rightExpr=AdditiveExpression)?;
 *
 **/

// leftExpr=MulExpression (op=AdditiveOperation rightExpr=AdditiveExpression)?
protected class AdditiveExpression_Group extends GroupToken {
	
	public AdditiveExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_LeftExprAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// leftExpr=MulExpression
protected class AdditiveExpression_LeftExprAssignment_0 extends AssignmentToken  {
	
	public AdditiveExpression_LeftExprAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getLeftExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MulExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("leftExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMulExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveExpressionAccess().getLeftExprMulExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (op=AdditiveOperation rightExpr=AdditiveExpression)?
protected class AdditiveExpression_Group_1 extends GroupToken {
	
	public AdditiveExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_RightExprAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// op=AdditiveOperation
protected class AdditiveExpression_OpAssignment_1_0 extends AssignmentToken  {
	
	public AdditiveExpression_OpAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getOpAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_LeftExprAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAdditiveExpressionAccess().getOpAdditiveOperationParserRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// rightExpr=AdditiveExpression
protected class AdditiveExpression_RightExprAssignment_1_1 extends AssignmentToken  {
	
	public AdditiveExpression_RightExprAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getRightExprAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveExpressionAccess().getRightExprAdditiveExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AdditiveExpression_OpAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AdditiveExpression ****************/


/************ begin Rule MulExpression ****************
 *
 * MulExpression:
 *   leftExpr=CastExpression (op=MulOperation rightExpr=MulExpression)?;
 *
 **/

// leftExpr=CastExpression (op=MulOperation rightExpr=MulExpression)?
protected class MulExpression_Group extends GroupToken {
	
	public MulExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMulExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MulExpression_Group_1(parent, this, 0, inst);
			case 1: return new MulExpression_LeftExprAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMulExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// leftExpr=CastExpression
protected class MulExpression_LeftExprAssignment_0 extends AssignmentToken  {
	
	public MulExpression_LeftExprAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMulExpressionAccess().getLeftExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("leftExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCastExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMulExpressionAccess().getLeftExprCastExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (op=MulOperation rightExpr=MulExpression)?
protected class MulExpression_Group_1 extends GroupToken {
	
	public MulExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMulExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MulExpression_RightExprAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// op=MulOperation
protected class MulExpression_OpAssignment_1_0 extends AssignmentToken  {
	
	public MulExpression_OpAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMulExpressionAccess().getOpAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MulExpression_LeftExprAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getMulExpressionAccess().getOpMulOperationParserRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// rightExpr=MulExpression
protected class MulExpression_RightExprAssignment_1_1 extends AssignmentToken  {
	
	public MulExpression_RightExprAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMulExpressionAccess().getRightExprAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MulExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMulExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMulExpressionAccess().getRightExprMulExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MulExpression_OpAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule MulExpression ****************/


/************ begin Rule CastExpression ****************
 *
 * CastExpression:
 *   "(" type=QualifiedTypeSpecification ")" expr=CastExpression|unaryExpr=
 *   UnaryExpression;
 *
 **/

// "(" type=QualifiedTypeSpecification ")" expr=CastExpression|unaryExpr=
// UnaryExpression
protected class CastExpression_Alternatives extends AlternativesToken {

	public CastExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCastExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastExpression_Group_0(parent, this, 0, inst);
			case 1: return new CastExpression_UnaryExprAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCastExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "(" type=QualifiedTypeSpecification ")" expr=CastExpression
protected class CastExpression_Group_0 extends GroupToken {
	
	public CastExpression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCastExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastExpression_ExprAssignment_0_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class CastExpression_LeftParenthesisKeyword_0_0 extends KeywordToken  {
	
	public CastExpression_LeftParenthesisKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCastExpressionAccess().getLeftParenthesisKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type=QualifiedTypeSpecification
protected class CastExpression_TypeAssignment_0_1 extends AssignmentToken  {
	
	public CastExpression_TypeAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCastExpressionAccess().getTypeAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCastExpressionAccess().getTypeQualifiedTypeSpecificationParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CastExpression_LeftParenthesisKeyword_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class CastExpression_RightParenthesisKeyword_0_2 extends KeywordToken  {
	
	public CastExpression_RightParenthesisKeyword_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCastExpressionAccess().getRightParenthesisKeyword_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastExpression_TypeAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expr=CastExpression
protected class CastExpression_ExprAssignment_0_3 extends AssignmentToken  {
	
	public CastExpression_ExprAssignment_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCastExpressionAccess().getExprAssignment_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCastExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCastExpressionAccess().getExprCastExpressionParserRuleCall_0_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CastExpression_RightParenthesisKeyword_0_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// unaryExpr=UnaryExpression
protected class CastExpression_UnaryExprAssignment_1 extends AssignmentToken  {
	
	public CastExpression_UnaryExprAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCastExpressionAccess().getUnaryExprAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("unaryExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("unaryExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCastExpressionAccess().getUnaryExprUnaryExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}


/************ end Rule CastExpression ****************/


/************ begin Rule UnaryExpression ****************
 *
 * UnaryExpression:
 *   unaryExpr=UnaryOperation? primaryExpr=PrimaryExpression;
 *
 **/

// unaryExpr=UnaryOperation? primaryExpr=PrimaryExpression
protected class UnaryExpression_Group extends GroupToken {
	
	public UnaryExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_PrimaryExprAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// unaryExpr=UnaryOperation?
protected class UnaryExpression_UnaryExprAssignment_0 extends AssignmentToken  {
	
	public UnaryExpression_UnaryExprAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getUnaryExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("unaryExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("unaryExpr");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getUnaryExpressionAccess().getUnaryExprUnaryOperationParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// primaryExpr=PrimaryExpression
protected class UnaryExpression_PrimaryExprAssignment_1 extends AssignmentToken  {
	
	public UnaryExpression_PrimaryExprAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getPrimaryExprAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("primaryExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("primaryExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryExpressionAccess().getPrimaryExprPrimaryExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryExpression_UnaryExprAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}


/************ end Rule UnaryExpression ****************/


/************ begin Rule PrimaryExpression ****************
 *
 * PrimaryExpression:
 *   literal=Literal|"(" ConstantExpression ")";
 *
 **/

// literal=Literal|"(" ConstantExpression ")"
protected class PrimaryExpression_Alternatives extends AlternativesToken {

	public PrimaryExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_LiteralAssignment_0(parent, this, 0, inst);
			case 1: return new PrimaryExpression_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// literal=Literal
protected class PrimaryExpression_LiteralAssignment_0 extends AssignmentToken  {
	
	public PrimaryExpression_LiteralAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getLiteralAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Literal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("literal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("literal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPrimaryExpressionAccess().getLiteralLiteralParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// "(" ConstantExpression ")"
protected class PrimaryExpression_Group_1 extends GroupToken {
	
	public PrimaryExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_RightParenthesisKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class PrimaryExpression_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public PrimaryExpression_LeftParenthesisKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// ConstantExpression
protected class PrimaryExpression_ConstantExpressionParserRuleCall_1_1 extends RuleCallToken {
	
	public PrimaryExpression_ConstantExpressionParserRuleCall_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getConstantExpressionParserRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantExpression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ConstantExpression_LogicalOrExpressionParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getConstantExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_LeftParenthesisKeyword_1_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class PrimaryExpression_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public PrimaryExpression_RightParenthesisKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_ConstantExpressionParserRuleCall_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule PrimaryExpression ****************/


/************ begin Rule Literal ****************
 *
 * Literal:
 *   ID|STRING|FloatingPointLiteral|ConstantDefinition|ref=[ConstantDefinition];
 *
 **/

// ID|STRING|FloatingPointLiteral|ConstantDefinition|ref=[ConstantDefinition]
protected class Literal_Alternatives extends AlternativesToken {

	public Literal_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLiteralAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Literal_IDTerminalRuleCall_0(parent, this, 0, inst);
			case 1: return new Literal_STRINGTerminalRuleCall_1(parent, this, 1, inst);
			case 2: return new Literal_FloatingPointLiteralParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Literal_ConstantDefinitionParserRuleCall_3(parent, this, 3, inst);
			case 4: return new Literal_RefAssignment_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ID
protected class Literal_IDTerminalRuleCall_0 extends UnassignedTextToken {

	public Literal_IDTerminalRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getIDTerminalRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// STRING
protected class Literal_STRINGTerminalRuleCall_1 extends UnassignedTextToken {

	public Literal_STRINGTerminalRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getSTRINGTerminalRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// FloatingPointLiteral
protected class Literal_FloatingPointLiteralParserRuleCall_2 extends UnassignedTextToken {

	public Literal_FloatingPointLiteralParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getFloatingPointLiteralParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// ConstantDefinition
protected class Literal_ConstantDefinitionParserRuleCall_3 extends RuleCallToken {
	
	public Literal_ConstantDefinitionParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getConstantDefinitionParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ConstantDefinition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ref=[ConstantDefinition]
protected class Literal_RefAssignment_4 extends AssignmentToken  {
	
	public Literal_RefAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralAccess().getRefAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ref",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ref");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLiteralAccess().getRefConstantDefinitionCrossReference_4_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getLiteralAccess().getRefConstantDefinitionCrossReference_4_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule Literal ****************/






}
