/*
* generated by Xtext
*/
package org.ow2.fractal.mind.idl.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.ow2.fractal.mind.idl.services.FractalIdtGrammarAccess;

import com.google.inject.Inject;

public class FractalIdtParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private FractalIdtGrammarAccess grammarAccess;
	
	@Override	
	public FractalIdtGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdtFile_Group(this, this, 0, inst);
			case 1: return new ItfFile_Group(this, this, 1, inst);
			case 2: return new TypeDefinition_Group(this, this, 2, inst);
			case 3: return new TypedefSpecification_Group(this, this, 3, inst);
			case 4: return new QualifiedTypeSpecification_Group(this, this, 4, inst);
			case 5: return new TypeSpecification_Alternatives(this, this, 5, inst);
			case 6: return new StructOrUnionSpecification_Alternatives(this, this, 6, inst);
			case 7: return new StructOrUnionDefinition_Group(this, this, 7, inst);
			case 8: return new StructorUnionReference_Group(this, this, 8, inst);
			case 9: return new StructMember_Group(this, this, 9, inst);
			case 10: return new EnumSpecification_Alternatives(this, this, 10, inst);
			case 11: return new EnumDefinition_Group(this, this, 11, inst);
			case 12: return new EnumReference_Group(this, this, 12, inst);
			case 13: return new EnumMemberList_Group(this, this, 13, inst);
			case 14: return new EnumMember_Group(this, this, 14, inst);
			case 15: return new Declarators_Group(this, this, 15, inst);
			case 16: return new Declarator_Group(this, this, 16, inst);
			case 17: return new DirectDeclarator_Group(this, this, 17, inst);
			case 18: return new ConstantDefinition_Group(this, this, 18, inst);
			case 19: return new InterfaceDefinition_Group(this, this, 19, inst);
			case 20: return new MethodDefinition_Group(this, this, 20, inst);
			case 21: return new ParameterList_Group(this, this, 21, inst);
			case 22: return new Parameter_Group(this, this, 22, inst);
			case 23: return new IncludeDirective_Group(this, this, 23, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule IdtFile ****************
 *
 * IdtFile:
 *   includes+=IncludeDirective* (constant+=ConstantDefinition|type+=TypeDefinition)*;
 *
 **/

// includes+=IncludeDirective* (constant+=ConstantDefinition|type+=TypeDefinition)*
protected class IdtFile_Group extends GroupToken {
	
	public IdtFile_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdtFile_Alternatives_1(parent, this, 0, inst);
			case 1: return new IdtFile_IncludesAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIdtFileRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// includes+=IncludeDirective*
protected class IdtFile_IncludesAssignment_0 extends AssignmentToken  {
	
	public IdtFile_IncludesAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getIncludesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("includes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("includes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIncludeDirectiveRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdtFileAccess().getIncludesIncludeDirectiveParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IdtFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// (constant+=ConstantDefinition|type+=TypeDefinition)*
protected class IdtFile_Alternatives_1 extends AlternativesToken {

	public IdtFile_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdtFile_ConstantAssignment_1_0(parent, this, 0, inst);
			case 1: return new IdtFile_TypeAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// constant+=ConstantDefinition
protected class IdtFile_ConstantAssignment_1_0 extends AssignmentToken  {
	
	public IdtFile_ConstantAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getConstantAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("constant",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("constant");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdtFileAccess().getConstantConstantDefinitionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IdtFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new IdtFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// type+=TypeDefinition
protected class IdtFile_TypeAssignment_1_1 extends AssignmentToken  {
	
	public IdtFile_TypeAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdtFileAccess().getTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdtFileAccess().getTypeTypeDefinitionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IdtFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new IdtFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}



/************ end Rule IdtFile ****************/


/************ begin Rule ItfFile ****************
 *
 * ItfFile:
 *   includes+=IncludeDirective* (constant+=ConstantDefinition|type+=TypeDefinition)*
 *   interface=InterfaceDefinition ";"?;   // itf definition
 * 
 * 
 * 
 *     
 *         // Type definition part
 *
 **/

// includes+=IncludeDirective* (constant+=ConstantDefinition|type+=TypeDefinition)*
// interface=InterfaceDefinition ";"?
protected class ItfFile_Group extends GroupToken {
	
	public ItfFile_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getItfFileAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ItfFile_InterfaceAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getItfFileRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// includes+=IncludeDirective*
protected class ItfFile_IncludesAssignment_0 extends AssignmentToken  {
	
	public ItfFile_IncludesAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getIncludesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("includes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("includes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIncludeDirectiveRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getIncludesIncludeDirectiveParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// (constant+=ConstantDefinition|type+=TypeDefinition)*
protected class ItfFile_Alternatives_1 extends AlternativesToken {

	public ItfFile_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getItfFileAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ItfFile_ConstantAssignment_1_0(parent, this, 0, inst);
			case 1: return new ItfFile_TypeAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// constant+=ConstantDefinition
protected class ItfFile_ConstantAssignment_1_0 extends AssignmentToken  {
	
	public ItfFile_ConstantAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getConstantAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("constant",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("constant");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getConstantConstantDefinitionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// type+=TypeDefinition
protected class ItfFile_TypeAssignment_1_1 extends AssignmentToken  {
	
	public ItfFile_TypeAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getTypeTypeDefinitionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}


// interface=InterfaceDefinition
protected class ItfFile_InterfaceAssignment_2 extends AssignmentToken  {
	
	public ItfFile_InterfaceAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getItfFileAccess().getInterfaceAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("interface",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("interface");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInterfaceDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getItfFileAccess().getInterfaceInterfaceDefinitionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ItfFile_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new ItfFile_IncludesAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}


/************ end Rule ItfFile ****************/


/************ begin Rule TypeDefinition ****************
 *
 * TypeDefinition:
 *   (TypedefSpecification|StructOrUnionSpecification|EnumSpecification) ";";   // Type definition part
 *
 **/

// (TypedefSpecification|StructOrUnionSpecification|EnumSpecification) ";"
protected class TypeDefinition_Group extends GroupToken {
	
	public TypeDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_SemicolonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TypedefSpecification|StructOrUnionSpecification|EnumSpecification
protected class TypeDefinition_Alternatives_0 extends AlternativesToken {

	public TypeDefinition_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_TypedefSpecificationParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new TypeDefinition_StructOrUnionSpecificationParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new TypeDefinition_EnumSpecificationParserRuleCall_0_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// TypedefSpecification
protected class TypeDefinition_TypedefSpecificationParserRuleCall_0_0 extends RuleCallToken {
	
	public TypeDefinition_TypedefSpecificationParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getTypedefSpecificationParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypedefSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypedefSpecification_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypedefSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StructOrUnionSpecification
protected class TypeDefinition_StructOrUnionSpecificationParserRuleCall_0_1 extends RuleCallToken {
	
	public TypeDefinition_StructOrUnionSpecificationParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getStructOrUnionSpecificationParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructOrUnionSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumSpecification
protected class TypeDefinition_EnumSpecificationParserRuleCall_0_2 extends RuleCallToken {
	
	public TypeDefinition_EnumSpecificationParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getEnumSpecificationParserRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


// ";"
protected class TypeDefinition_SemicolonKeyword_1 extends KeywordToken  {
	
	public TypeDefinition_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeDefinitionAccess().getSemicolonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDefinition_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule TypeDefinition ****************/


/************ begin Rule TypedefSpecification ****************
 *
 * TypedefSpecification:
 *   "typedef" qualifedType=QualifiedTypeSpecification dec=Declarators;
 *
 **/

// "typedef" qualifedType=QualifiedTypeSpecification dec=Declarators
protected class TypedefSpecification_Group extends GroupToken {
	
	public TypedefSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypedefSpecification_DecAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypedefSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "typedef"
protected class TypedefSpecification_TypedefKeyword_0 extends KeywordToken  {
	
	public TypedefSpecification_TypedefKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getTypedefKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// qualifedType=QualifiedTypeSpecification
protected class TypedefSpecification_QualifedTypeAssignment_1 extends AssignmentToken  {
	
	public TypedefSpecification_QualifedTypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getQualifedTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifedType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifedType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypedefSpecificationAccess().getQualifedTypeQualifiedTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypedefSpecification_TypedefKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// dec=Declarators
protected class TypedefSpecification_DecAssignment_2 extends AssignmentToken  {
	
	public TypedefSpecification_DecAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypedefSpecificationAccess().getDecAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypedefSpecificationAccess().getDecDeclaratorsParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypedefSpecification_QualifedTypeAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule TypedefSpecification ****************/


/************ begin Rule QualifiedTypeSpecification ****************
 *
 * QualifiedTypeSpecification:
 *   typeQualifier+=TypeQualifier* typeSpec=TypeSpecification;
 *
 **/

// typeQualifier+=TypeQualifier* typeSpec=TypeSpecification
protected class QualifiedTypeSpecification_Group extends GroupToken {
	
	public QualifiedTypeSpecification_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQualifiedTypeSpecificationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_TypeSpecAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// typeQualifier+=TypeQualifier*
protected class QualifiedTypeSpecification_TypeQualifierAssignment_0 extends AssignmentToken  {
	
	public QualifiedTypeSpecification_TypeQualifierAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQualifiedTypeSpecificationAccess().getTypeQualifierAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_TypeQualifierAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeQualifier",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeQualifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getQualifiedTypeSpecificationAccess().getTypeQualifierTypeQualifierEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// typeSpec=TypeSpecification
protected class QualifiedTypeSpecification_TypeSpecAssignment_1 extends AssignmentToken  {
	
	public QualifiedTypeSpecification_TypeSpecAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQualifiedTypeSpecificationAccess().getTypeSpecAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeSpec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeSpec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getQualifiedTypeSpecificationAccess().getTypeSpecTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new QualifiedTypeSpecification_TypeQualifierAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}


/************ end Rule QualifiedTypeSpecification ****************/


/************ begin Rule TypeSpecification ****************
 *
 * TypeSpecification:
 *   typeDefName=TypedefName|StructOrUnionSpecification|EnumSpecification|
 *   typeSpecifier+=TypeSpecifier+;
 *
 **/

// typeDefName=TypedefName|StructOrUnionSpecification|EnumSpecification|
// typeSpecifier+=TypeSpecifier+
protected class TypeSpecification_Alternatives extends AlternativesToken {

	public TypeSpecification_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeSpecification_TypeDefNameAssignment_0(parent, this, 0, inst);
			case 1: return new TypeSpecification_StructOrUnionSpecificationParserRuleCall_1(parent, this, 1, inst);
			case 2: return new TypeSpecification_EnumSpecificationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new TypeSpecification_TypeSpecifierAssignment_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// typeDefName=TypedefName
protected class TypeSpecification_TypeDefNameAssignment_0 extends AssignmentToken  {
	
	public TypeSpecification_TypeDefNameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getTypeDefNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeDefName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeDefName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getTypeSpecificationAccess().getTypeDefNameTypedefNameParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// StructOrUnionSpecification
protected class TypeSpecification_StructOrUnionSpecificationParserRuleCall_1 extends RuleCallToken {
	
	public TypeSpecification_StructOrUnionSpecificationParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getStructOrUnionSpecificationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructOrUnionSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumSpecification
protected class TypeSpecification_EnumSpecificationParserRuleCall_2 extends RuleCallToken {
	
	public TypeSpecification_EnumSpecificationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getEnumSpecificationParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumSpecification_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumSpecification_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumSpecificationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// typeSpecifier+=TypeSpecifier+
protected class TypeSpecification_TypeSpecifierAssignment_3 extends AssignmentToken  {
	
	public TypeSpecification_TypeSpecifierAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeSpecificationAccess().getTypeSpecifierAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeSpecification_TypeSpecifierAssignment_3(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeSpecifier",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeSpecifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getTypeSpecificationAccess().getTypeSpecifierTypeSpecifierEnumRuleCall_3_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule TypeSpecification ****************/



/************ begin Rule StructOrUnionSpecification ****************
 *
 * StructOrUnionSpecification:
 *   StructOrUnionDefinition|StructorUnionReference;
 *
 **/

// StructOrUnionDefinition|StructorUnionReference
protected class StructOrUnionSpecification_Alternatives extends AlternativesToken {

	public StructOrUnionSpecification_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getStructOrUnionSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionSpecification_StructOrUnionDefinitionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new StructOrUnionSpecification_StructorUnionReferenceParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// StructOrUnionDefinition
protected class StructOrUnionSpecification_StructOrUnionDefinitionParserRuleCall_0 extends RuleCallToken {
	
	public StructOrUnionSpecification_StructOrUnionDefinitionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructOrUnionSpecificationAccess().getStructOrUnionDefinitionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructOrUnionDefinition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionDefinitionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StructorUnionReference
protected class StructOrUnionSpecification_StructorUnionReferenceParserRuleCall_1 extends RuleCallToken {
	
	public StructOrUnionSpecification_StructorUnionReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructOrUnionSpecificationAccess().getStructorUnionReferenceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructorUnionReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructorUnionReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructorUnionReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule StructOrUnionSpecification ****************/


/************ begin Rule StructOrUnionDefinition ****************
 *
 * StructOrUnionDefinition:
 *   struct=StructOrUnion id=ID? "{" structMember+=StructMember* "}";
 *
 **/

// struct=StructOrUnion id=ID? "{" structMember+=StructMember* "}"
protected class StructOrUnionDefinition_Group extends GroupToken {
	
	public StructOrUnionDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructOrUnionDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// struct=StructOrUnion
protected class StructOrUnionDefinition_StructAssignment_0 extends AssignmentToken  {
	
	public StructOrUnionDefinition_StructAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getStructAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("struct",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("struct");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getStructOrUnionDefinitionAccess().getStructStructOrUnionParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// id=ID?
protected class StructOrUnionDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public StructOrUnionDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_StructAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStructOrUnionDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class StructOrUnionDefinition_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public StructOrUnionDefinition_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_IdAssignment_1(parent, this, 0, inst);
			case 1: return new StructOrUnionDefinition_StructAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// structMember+=StructMember*
protected class StructOrUnionDefinition_StructMemberAssignment_3 extends AssignmentToken  {
	
	public StructOrUnionDefinition_StructMemberAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getStructMemberAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("structMember",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("structMember");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStructMemberRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructOrUnionDefinitionAccess().getStructMemberStructMemberParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StructOrUnionDefinition_StructMemberAssignment_3(parent, next, actIndex, consumed);
			case 1: return new StructOrUnionDefinition_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class StructOrUnionDefinition_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public StructOrUnionDefinition_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructOrUnionDefinitionAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructOrUnionDefinition_StructMemberAssignment_3(parent, this, 0, inst);
			case 1: return new StructOrUnionDefinition_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule StructOrUnionDefinition ****************/


/************ begin Rule StructorUnionReference ****************
 *
 * StructorUnionReference:
 *   struct=StructOrUnion id=ID;
 *
 **/

// struct=StructOrUnion id=ID
protected class StructorUnionReference_Group extends GroupToken {
	
	public StructorUnionReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructorUnionReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructorUnionReference_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructorUnionReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// struct=StructOrUnion
protected class StructorUnionReference_StructAssignment_0 extends AssignmentToken  {
	
	public StructorUnionReference_StructAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructorUnionReferenceAccess().getStructAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("struct",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("struct");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getStructorUnionReferenceAccess().getStructStructOrUnionParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// id=ID
protected class StructorUnionReference_IdAssignment_1 extends AssignmentToken  {
	
	public StructorUnionReference_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructorUnionReferenceAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructorUnionReference_StructAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStructorUnionReferenceAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule StructorUnionReference ****************/



/************ begin Rule StructMember ****************
 *
 * StructMember:
 *   qualType=QualifiedTypeSpecification dec=Declarators (":" INT)? ";";
 *
 **/

// qualType=QualifiedTypeSpecification dec=Declarators (":" INT)? ";"
protected class StructMember_Group extends GroupToken {
	
	public StructMember_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_SemicolonKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructMemberRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// qualType=QualifiedTypeSpecification
protected class StructMember_QualTypeAssignment_0 extends AssignmentToken  {
	
	public StructMember_QualTypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getQualTypeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructMemberAccess().getQualTypeQualifiedTypeSpecificationParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// dec=Declarators
protected class StructMember_DecAssignment_1 extends AssignmentToken  {
	
	public StructMember_DecAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getDecAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStructMemberAccess().getDecDeclaratorsParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StructMember_QualTypeAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// (":" INT)?
protected class StructMember_Group_2 extends GroupToken {
	
	public StructMember_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_INTTerminalRuleCall_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class StructMember_ColonKeyword_2_0 extends KeywordToken  {
	
	public StructMember_ColonKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getColonKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_DecAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// INT
protected class StructMember_INTTerminalRuleCall_2_1 extends UnassignedTextToken {

	public StructMember_INTTerminalRuleCall_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getINTTerminalRuleCall_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_ColonKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// ";"
protected class StructMember_SemicolonKeyword_3 extends KeywordToken  {
	
	public StructMember_SemicolonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStructMemberAccess().getSemicolonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructMember_Group_2(parent, this, 0, inst);
			case 1: return new StructMember_DecAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule StructMember ****************/


/************ begin Rule EnumSpecification ****************
 *
 * EnumSpecification:
 *   EnumDefinition|EnumReference;
 *
 **/

// EnumDefinition|EnumReference
protected class EnumSpecification_Alternatives extends AlternativesToken {

	public EnumSpecification_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEnumSpecificationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumSpecification_EnumDefinitionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new EnumSpecification_EnumReferenceParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumSpecificationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// EnumDefinition
protected class EnumSpecification_EnumDefinitionParserRuleCall_0 extends RuleCallToken {
	
	public EnumSpecification_EnumDefinitionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumSpecificationAccess().getEnumDefinitionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumDefinition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumDefinitionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumReference
protected class EnumSpecification_EnumReferenceParserRuleCall_1 extends RuleCallToken {
	
	public EnumSpecification_EnumReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumSpecificationAccess().getEnumReferenceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule EnumSpecification ****************/


/************ begin Rule EnumDefinition ****************
 *
 * EnumDefinition:
 *   "enum" id=ID? "{" enumMemberList=EnumMemberList "}";
 *
 **/

// "enum" id=ID? "{" enumMemberList=EnumMemberList "}"
protected class EnumDefinition_Group extends GroupToken {
	
	public EnumDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "enum"
protected class EnumDefinition_EnumKeyword_0 extends KeywordToken  {
	
	public EnumDefinition_EnumKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getEnumKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID?
protected class EnumDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public EnumDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_EnumKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class EnumDefinition_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public EnumDefinition_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_IdAssignment_1(parent, this, 0, inst);
			case 1: return new EnumDefinition_EnumKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// enumMemberList=EnumMemberList
protected class EnumDefinition_EnumMemberListAssignment_3 extends AssignmentToken  {
	
	public EnumDefinition_EnumMemberListAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getEnumMemberListAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("enumMemberList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("enumMemberList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumMemberListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumDefinitionAccess().getEnumMemberListEnumMemberListParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumDefinition_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class EnumDefinition_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public EnumDefinition_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumDefinitionAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumDefinition_EnumMemberListAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule EnumDefinition ****************/


/************ begin Rule EnumReference ****************
 *
 * EnumReference:
 *   "enum" id=ID;
 *
 **/

// "enum" id=ID
protected class EnumReference_Group extends GroupToken {
	
	public EnumReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumReference_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "enum"
protected class EnumReference_EnumKeyword_0 extends KeywordToken  {
	
	public EnumReference_EnumKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumReferenceAccess().getEnumKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID
protected class EnumReference_IdAssignment_1 extends AssignmentToken  {
	
	public EnumReference_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumReferenceAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumReference_EnumKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumReferenceAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule EnumReference ****************/


/************ begin Rule EnumMemberList ****************
 *
 * EnumMemberList:
 *   EnumMember ("," enumMember+=EnumMember)*;
 *
 **/

// EnumMember ("," enumMember+=EnumMember)*
protected class EnumMemberList_Group extends GroupToken {
	
	public EnumMemberList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_Group_1(parent, this, 0, inst);
			case 1: return new EnumMemberList_EnumMemberParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumMemberListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// EnumMember
protected class EnumMemberList_EnumMemberParserRuleCall_0 extends RuleCallToken {
	
	public EnumMemberList_EnumMemberParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getEnumMemberParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumMember_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumMemberRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ("," enumMember+=EnumMember)*
protected class EnumMemberList_Group_1 extends GroupToken {
	
	public EnumMemberList_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_EnumMemberAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class EnumMemberList_CommaKeyword_1_0 extends KeywordToken  {
	
	public EnumMemberList_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMemberList_Group_1(parent, this, 0, inst);
			case 1: return new EnumMemberList_EnumMemberParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// enumMember+=EnumMember
protected class EnumMemberList_EnumMemberAssignment_1_1 extends AssignmentToken  {
	
	public EnumMemberList_EnumMemberAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumMemberListAccess().getEnumMemberAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("enumMember",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("enumMember");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumMemberRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumMemberListAccess().getEnumMemberEnumMemberParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumMemberList_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule EnumMemberList ****************/


/************ begin Rule EnumMember ****************
 *
 * EnumMember:
 *   id=ID ("=" INT)?;
 *
 **/

// id=ID ("=" INT)?
protected class EnumMember_Group extends GroupToken {
	
	public EnumMember_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_Group_1(parent, this, 0, inst);
			case 1: return new EnumMember_IdAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumMemberRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// id=ID
protected class EnumMember_IdAssignment_0 extends AssignmentToken  {
	
	public EnumMember_IdAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getIdAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumMemberAccess().getIdIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("=" INT)?
protected class EnumMember_Group_1 extends GroupToken {
	
	public EnumMember_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_INTTerminalRuleCall_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class EnumMember_EqualsSignKeyword_1_0 extends KeywordToken  {
	
	public EnumMember_EqualsSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getEqualsSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_IdAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// INT
protected class EnumMember_INTTerminalRuleCall_1_1 extends UnassignedTextToken {

	public EnumMember_INTTerminalRuleCall_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumMemberAccess().getINTTerminalRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumMember_EqualsSignKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule EnumMember ****************/


/************ begin Rule Declarators ****************
 *
 * Declarators:
 *   dec=Declarator ("," declaratorList+=Declarator)*;
 *
 **/

// dec=Declarator ("," declaratorList+=Declarator)*
protected class Declarators_Group extends GroupToken {
	
	public Declarators_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group_1(parent, this, 0, inst);
			case 1: return new Declarators_DecAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclaratorsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// dec=Declarator
protected class Declarators_DecAssignment_0 extends AssignmentToken  {
	
	public Declarators_DecAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getDecAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorsAccess().getDecDeclaratorParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," declaratorList+=Declarator)*
protected class Declarators_Group_1 extends GroupToken {
	
	public Declarators_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_DeclaratorListAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Declarators_CommaKeyword_1_0 extends KeywordToken  {
	
	public Declarators_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarators_Group_1(parent, this, 0, inst);
			case 1: return new Declarators_DecAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// declaratorList+=Declarator
protected class Declarators_DeclaratorListAssignment_1_1 extends AssignmentToken  {
	
	public Declarators_DeclaratorListAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorsAccess().getDeclaratorListAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("declaratorList",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("declaratorList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorsAccess().getDeclaratorListDeclaratorParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Declarators_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Declarators ****************/


/************ begin Rule Declarator ****************
 *
 * Declarator:
 *   ("*" typeQualifier+=TypeQualifier*)* dc=DirectDeclarator; 
 * 
 * 
 *         //PointerSpecification:
 * //  qualifiedPointer+=(qualified_PointerSpecification)*;
 * //
 * //qualified_PointerSpecification:
 * //  '*' (typeQualifier+=TypeQualifier)*;
 *
 **/

// ("*" typeQualifier+=TypeQualifier*)* dc=DirectDeclarator
protected class Declarator_Group extends GroupToken {
	
	public Declarator_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_DcAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ("*" typeQualifier+=TypeQualifier*)*
protected class Declarator_Group_0 extends GroupToken {
	
	public Declarator_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_TypeQualifierAssignment_0_1(parent, this, 0, inst);
			case 1: return new Declarator_AsteriskKeyword_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "*"
protected class Declarator_AsteriskKeyword_0_0 extends KeywordToken  {
	
	public Declarator_AsteriskKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getAsteriskKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// typeQualifier+=TypeQualifier*
protected class Declarator_TypeQualifierAssignment_0_1 extends AssignmentToken  {
	
	public Declarator_TypeQualifierAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getTypeQualifierAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_TypeQualifierAssignment_0_1(parent, this, 0, inst);
			case 1: return new Declarator_AsteriskKeyword_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeQualifier",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeQualifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getDeclaratorAccess().getTypeQualifierTypeQualifierEnumRuleCall_0_1_0();
			return obj;
		}
		return null;
	}

}


// dc=DirectDeclarator
protected class Declarator_DcAssignment_1 extends AssignmentToken  {
	
	public Declarator_DcAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaratorAccess().getDcAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dc",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dc");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDirectDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaratorAccess().getDcDirectDeclaratorParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Declarator_Group_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}


/************ end Rule Declarator ****************/


/************ begin Rule DirectDeclarator ****************
 *
 * DirectDeclarator:
 *   (id=ID|"(" Declarator ")") ArraySpecification*;   //PointerSpecification:
 * //  qualifiedPointer+=(qualified_PointerSpecification)*;
 * //
 * //qualified_PointerSpecification:
 * //  '*' (typeQualifier+=TypeQualifier)*;
 *
 **/

// (id=ID|"(" Declarator ")") ArraySpecification*
protected class DirectDeclarator_Group extends GroupToken {
	
	public DirectDeclarator_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_ArraySpecificationParserRuleCall_1(parent, this, 0, inst);
			case 1: return new DirectDeclarator_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDirectDeclaratorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// id=ID|"(" Declarator ")"
protected class DirectDeclarator_Alternatives_0 extends AlternativesToken {

	public DirectDeclarator_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_IdAssignment_0_0(parent, this, 0, inst);
			case 1: return new DirectDeclarator_Group_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// id=ID
protected class DirectDeclarator_IdAssignment_0_0 extends AssignmentToken  {
	
	public DirectDeclarator_IdAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getIdAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDirectDeclaratorAccess().getIdIDTerminalRuleCall_0_0_0();
			return obj;
		}
		return null;
	}

}

// "(" Declarator ")"
protected class DirectDeclarator_Group_0_1 extends GroupToken {
	
	public DirectDeclarator_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_RightParenthesisKeyword_0_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class DirectDeclarator_LeftParenthesisKeyword_0_1_0 extends KeywordToken  {
	
	public DirectDeclarator_LeftParenthesisKeyword_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getLeftParenthesisKeyword_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// Declarator
protected class DirectDeclarator_DeclaratorParserRuleCall_0_1_1 extends RuleCallToken {
	
	public DirectDeclarator_DeclaratorParserRuleCall_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getDeclaratorParserRuleCall_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Declarator_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_LeftParenthesisKeyword_0_1_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class DirectDeclarator_RightParenthesisKeyword_0_1_2 extends KeywordToken  {
	
	public DirectDeclarator_RightParenthesisKeyword_0_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getRightParenthesisKeyword_0_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_DeclaratorParserRuleCall_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// ArraySpecification*
protected class DirectDeclarator_ArraySpecificationParserRuleCall_1 extends UnassignedTextToken {

	public DirectDeclarator_ArraySpecificationParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDirectDeclaratorAccess().getArraySpecificationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DirectDeclarator_ArraySpecificationParserRuleCall_1(parent, this, 0, inst);
			case 1: return new DirectDeclarator_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule DirectDeclarator ****************/




/************ begin Rule ConstantDefinition ****************
 *
 * ConstantDefinition:
 *   "#define" id=ID INT;   // Interface definition part
 *
 **/

// "#define" id=ID INT
protected class ConstantDefinition_Group extends GroupToken {
	
	public ConstantDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_INTTerminalRuleCall_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstantDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "#define"
protected class ConstantDefinition_DefineKeyword_0 extends KeywordToken  {
	
	public ConstantDefinition_DefineKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getDefineKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID
protected class ConstantDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public ConstantDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_DefineKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getConstantDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// INT
protected class ConstantDefinition_INTTerminalRuleCall_2 extends UnassignedTextToken {

	public ConstantDefinition_INTTerminalRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getConstantDefinitionAccess().getINTTerminalRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstantDefinition_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ConstantDefinition ****************/


/************ begin Rule InterfaceDefinition ****************
 *
 * InterfaceDefinition:
 *   "interface" "unmanaged"? fqn=FullyQualifiedName (":" fqn2=FullyQualifiedName)? "{"
 *   methodDef+=MethodDefinition* "}";
 *
 **/

// "interface" "unmanaged"? fqn=FullyQualifiedName (":" fqn2=FullyQualifiedName)? "{"
// methodDef+=MethodDefinition* "}"
protected class InterfaceDefinition_Group extends GroupToken {
	
	public InterfaceDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_RightCurlyBracketKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInterfaceDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "interface"
protected class InterfaceDefinition_InterfaceKeyword_0 extends KeywordToken  {
	
	public InterfaceDefinition_InterfaceKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getInterfaceKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// fqn=FullyQualifiedName
protected class InterfaceDefinition_FqnAssignment_2 extends AssignmentToken  {
	
	public InterfaceDefinition_FqnAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getFqnAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_InterfaceKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fqn",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fqn");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getInterfaceDefinitionAccess().getFqnFullyQualifiedNameParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// (":" fqn2=FullyQualifiedName)?
protected class InterfaceDefinition_Group_3 extends GroupToken {
	
	public InterfaceDefinition_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_Fqn2Assignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class InterfaceDefinition_ColonKeyword_3_0 extends KeywordToken  {
	
	public InterfaceDefinition_ColonKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getColonKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_FqnAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// fqn2=FullyQualifiedName
protected class InterfaceDefinition_Fqn2Assignment_3_1 extends AssignmentToken  {
	
	public InterfaceDefinition_Fqn2Assignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getFqn2Assignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_ColonKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fqn2",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fqn2");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getInterfaceDefinitionAccess().getFqn2FullyQualifiedNameParserRuleCall_3_1_0();
			return obj;
		}
		return null;
	}

}


// "{"
protected class InterfaceDefinition_LeftCurlyBracketKeyword_4 extends KeywordToken  {
	
	public InterfaceDefinition_LeftCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getLeftCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_Group_3(parent, this, 0, inst);
			case 1: return new InterfaceDefinition_FqnAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// methodDef+=MethodDefinition*
protected class InterfaceDefinition_MethodDefAssignment_5 extends AssignmentToken  {
	
	public InterfaceDefinition_MethodDefAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getMethodDefAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("methodDef",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("methodDef");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMethodDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInterfaceDefinitionAccess().getMethodDefMethodDefinitionParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InterfaceDefinition_MethodDefAssignment_5(parent, next, actIndex, consumed);
			case 1: return new InterfaceDefinition_LeftCurlyBracketKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class InterfaceDefinition_RightCurlyBracketKeyword_6 extends KeywordToken  {
	
	public InterfaceDefinition_RightCurlyBracketKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInterfaceDefinitionAccess().getRightCurlyBracketKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InterfaceDefinition_MethodDefAssignment_5(parent, this, 0, inst);
			case 1: return new InterfaceDefinition_LeftCurlyBracketKeyword_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule InterfaceDefinition ****************/


/************ begin Rule MethodDefinition ****************
 *
 * MethodDefinition:
 *   qualifiedTypeSpec=QualifiedTypeSpecification id=ID ("(" "void"? ")"|"(" ParameterList
 *   =ParameterList ")") ";";
 *
 **/

// qualifiedTypeSpec=QualifiedTypeSpecification id=ID ("(" "void"? ")"|"(" ParameterList
// =ParameterList ")") ";"
protected class MethodDefinition_Group extends GroupToken {
	
	public MethodDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_SemicolonKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMethodDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// qualifiedTypeSpec=QualifiedTypeSpecification
protected class MethodDefinition_QualifiedTypeSpecAssignment_0 extends AssignmentToken  {
	
	public MethodDefinition_QualifiedTypeSpecAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getQualifiedTypeSpecAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifiedTypeSpec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifiedTypeSpec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethodDefinitionAccess().getQualifiedTypeSpecQualifiedTypeSpecificationParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// id=ID
protected class MethodDefinition_IdAssignment_1 extends AssignmentToken  {
	
	public MethodDefinition_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_QualifiedTypeSpecAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMethodDefinitionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "(" "void"? ")"|"(" ParameterList=ParameterList ")"
protected class MethodDefinition_Alternatives_2 extends AlternativesToken {

	public MethodDefinition_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_Group_2_0(parent, this, 0, inst);
			case 1: return new MethodDefinition_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "(" "void"? ")"
protected class MethodDefinition_Group_2_0 extends GroupToken {
	
	public MethodDefinition_Group_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getGroup_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_RightParenthesisKeyword_2_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class MethodDefinition_LeftParenthesisKeyword_2_0_0 extends KeywordToken  {
	
	public MethodDefinition_LeftParenthesisKeyword_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getLeftParenthesisKeyword_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ")"
protected class MethodDefinition_RightParenthesisKeyword_2_0_2 extends KeywordToken  {
	
	public MethodDefinition_RightParenthesisKeyword_2_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getRightParenthesisKeyword_2_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_LeftParenthesisKeyword_2_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "(" ParameterList=ParameterList ")"
protected class MethodDefinition_Group_2_1 extends GroupToken {
	
	public MethodDefinition_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_RightParenthesisKeyword_2_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class MethodDefinition_LeftParenthesisKeyword_2_1_0 extends KeywordToken  {
	
	public MethodDefinition_LeftParenthesisKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getLeftParenthesisKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_IdAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ParameterList=ParameterList
protected class MethodDefinition_ParameterListAssignment_2_1_1 extends AssignmentToken  {
	
	public MethodDefinition_ParameterListAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getParameterListAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ParameterList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ParameterList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethodDefinitionAccess().getParameterListParameterListParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MethodDefinition_LeftParenthesisKeyword_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class MethodDefinition_RightParenthesisKeyword_2_1_2 extends KeywordToken  {
	
	public MethodDefinition_RightParenthesisKeyword_2_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getRightParenthesisKeyword_2_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_ParameterListAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// ";"
protected class MethodDefinition_SemicolonKeyword_3 extends KeywordToken  {
	
	public MethodDefinition_SemicolonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodDefinitionAccess().getSemicolonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodDefinition_Alternatives_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule MethodDefinition ****************/


/************ begin Rule ParameterList ****************
 *
 * ParameterList:
 *   param=Parameter ("," params+=Parameter)* ("," "...")?;
 *
 **/

// param=Parameter ("," params+=Parameter)* ("," "...")?
protected class ParameterList_Group extends GroupToken {
	
	public ParameterList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group_1(parent, this, 0, inst);
			case 1: return new ParameterList_ParamAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// param=Parameter
protected class ParameterList_ParamAssignment_0 extends AssignmentToken  {
	
	public ParameterList_ParamAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterListAccess().getParamAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("param",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("param");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterListAccess().getParamParameterParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," params+=Parameter)*
protected class ParameterList_Group_1 extends GroupToken {
	
	public ParameterList_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterListAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_ParamsAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ParameterList_CommaKeyword_1_0 extends KeywordToken  {
	
	public ParameterList_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParameterListAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group_1(parent, this, 0, inst);
			case 1: return new ParameterList_ParamAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Parameter
protected class ParameterList_ParamsAssignment_1_1 extends AssignmentToken  {
	
	public ParameterList_ParamsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterListAccess().getParamsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterListAccess().getParamsParameterParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ParameterList_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ParameterList ****************/


/************ begin Rule Parameter ****************
 *
 * Parameter:
 *   ParameterQualifier+=ParameterQualifier* qualifiedTypeSpec=
 *   QualifiedTypeSpecification dec=Declarator;
 *
 **/

// ParameterQualifier+=ParameterQualifier* qualifiedTypeSpec=
// QualifiedTypeSpecification dec=Declarator
protected class Parameter_Group extends GroupToken {
	
	public Parameter_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_DecAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ParameterQualifier+=ParameterQualifier*
protected class Parameter_ParameterQualifierAssignment_0 extends AssignmentToken  {
	
	public Parameter_ParameterQualifierAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getParameterQualifierAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_ParameterQualifierAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ParameterQualifier",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ParameterQualifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getParameterAccess().getParameterQualifierParameterQualifierEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// qualifiedTypeSpec=QualifiedTypeSpecification
protected class Parameter_QualifiedTypeSpecAssignment_1 extends AssignmentToken  {
	
	public Parameter_QualifiedTypeSpecAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getQualifiedTypeSpecAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QualifiedTypeSpecification_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifiedTypeSpec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifiedTypeSpec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQualifiedTypeSpecificationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterAccess().getQualifiedTypeSpecQualifiedTypeSpecificationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Parameter_ParameterQualifierAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// dec=Declarator
protected class Parameter_DecAssignment_2 extends AssignmentToken  {
	
	public Parameter_DecAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getDecAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declarator_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("dec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("dec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaratorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterAccess().getDecDeclaratorParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Parameter_QualifiedTypeSpecAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Parameter ****************/


/************ begin Rule IncludeDirective ****************
 *
 * IncludeDirective:
 *   "#include" (importedURI=STRING|includeID=IncludeLib);   // include directive
 *
 **/

// "#include" (importedURI=STRING|includeID=IncludeLib)
protected class IncludeDirective_Group extends GroupToken {
	
	public IncludeDirective_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIncludeDirectiveRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "#include"
protected class IncludeDirective_IncludeKeyword_0 extends KeywordToken  {
	
	public IncludeDirective_IncludeKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getIncludeKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// importedURI=STRING|includeID=IncludeLib
protected class IncludeDirective_Alternatives_1 extends AlternativesToken {

	public IncludeDirective_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_ImportedURIAssignment_1_0(parent, this, 0, inst);
			case 1: return new IncludeDirective_IncludeIDAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// importedURI=STRING
protected class IncludeDirective_ImportedURIAssignment_1_0 extends AssignmentToken  {
	
	public IncludeDirective_ImportedURIAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getImportedURIAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_IncludeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("importedURI",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("importedURI");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getIncludeDirectiveAccess().getImportedURISTRINGTerminalRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// includeID=IncludeLib
protected class IncludeDirective_IncludeIDAssignment_1_1 extends AssignmentToken  {
	
	public IncludeDirective_IncludeIDAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIncludeDirectiveAccess().getIncludeIDAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDirective_IncludeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("includeID",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("includeID");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getIncludeDirectiveAccess().getIncludeIDIncludeLibTerminalRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule IncludeDirective ****************/

}
